"use strict";(()=>{var St=Object.defineProperty;var Ut=(o,e)=>()=>(o&&(e=o(o=0)),e);var Rt=(o,e)=>{for(var t in e)St(o,t,{get:e[t],enumerable:!0})};var qe={};Rt(qe,{BrowserSignatureAlgs:()=>ie,DPoPSignatureProvider:()=>$e});async function Ft(o,e){let t=new TextEncoder,r=t.encode(o),i=await crypto.subtle.digest("SHA-256",r),n=new Uint8Array(i),s=Array.from(n.slice(0,8)).map(u=>u.toString(16).padStart(2,"0")).join(""),c=t.encode(e),l=await crypto.subtle.digest("SHA-256",c),d=new Uint8Array(l),h=Array.from(d.slice(0,8)).map(u=>u.toString(16).padStart(2,"0")).join("");return`dpop:${s}:${h}`}async function Bt(o){let t=new TextEncoder().encode(o);if(typeof crypto>"u"||typeof crypto.subtle>"u")throw new Error("Web Crypto API is not available.");return await crypto.subtle.digest("SHA-256",t)}function ye(o){let e=o instanceof Uint8Array?o:new Uint8Array(o),t=String.fromCharCode(...e);return btoa(t).replaceAll("+","-").replaceAll("/","_").replaceAll("=","")}var R,y,Le,Ee,U,Q,le,ke,_e,be,ct,de,H,O,re,Te,lt,dt,ie,Ot,Z,Me,Ht,zt,Vt,Ne,$e,Oe=Ut(()=>{R=function(o,e,t,r,i){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!i)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?o!==e||!i:!e.has(o))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?i.call(o,t):i?i.value=t:e.set(o,t),t},y=function(o,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?o!==e||!r:!e.has(o))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(o):r?r.value:e.get(o)},ie={ES256:"ES256",ES384:"ES384",ES512:"ES512",EdDSA:"EdDSA"},Ot=1,Z="main",Me="dpopState",Ht={ES256:{name:"ECDSA",namedCurve:"P-256"},ES384:{name:"ECDSA",namedCurve:"P-384"},ES512:{name:"ECDSA",namedCurve:"P-521"},EdDSA:{name:"Ed25519"}},zt={ES256:{name:"ECDSA",hash:"SHA-256"},ES384:{name:"ECDSA",hash:"SHA-384"},ES512:{name:"ECDSA",hash:"SHA-512"},EdDSA:{name:"Ed25519"}},Vt=[ie.ES256,ie.ES384,ie.ES512];Ne=class{constructor(e,t,r=!1){Le.add(this),Ee.set(this,""),U.set(this,null),Q.set(this,!1),le.set(this,void 0),ke.set(this,void 0),_e.set(this,void 0),be.set(this,void 0),R(this,ke,e,"f"),R(this,_e,t,"f"),R(this,be,r,"f")}async init(){if(y(this,U,"f")||y(this,Q,"f"))return this;try{R(this,Ee,await Ft(y(this,ke,"f"),y(this,_e,"f")),"f"),R(this,U,await y(this,Le,"m",ct).call(this),"f")}catch(e){if(y(this,be,"f"))throw new Error("DPoP requires IndexedDB for secure key storage, but it is unavailable.",{cause:e});console.warn("[KEYCLOAK] IndexedDB unavailable, falling back to in-memory storage:",e),R(this,Q,!0,"f")}return this}async get(){if(y(this,Q,"f"))return y(this,le,"f");if(!y(this,U,"f"))throw new Error("DPoPStoreManager not initialized. Call init() first.");return new Promise((e,t)=>{let n=y(this,U,"f").transaction(Z,"readonly").objectStore(Z).get(Me);n.onerror=()=>{t(n.error)},n.onsuccess=()=>{e(n.result)}})}async set(e){if(y(this,Q,"f")){R(this,le,e,"f");return}if(!y(this,U,"f"))throw new Error("DPoPStoreManager not initialized. Call init() first.");return new Promise((t,r)=>{let s=y(this,U,"f").transaction(Z,"readwrite").objectStore(Z).put(e,Me);s.onerror=()=>{r(s.error)},s.onsuccess=()=>{t()}})}async flush(){if(y(this,Q,"f")){R(this,le,void 0,"f");return}if(!y(this,U,"f"))throw new Error("DPoPStoreManager not initialized. Call init() first.");return new Promise((e,t)=>{let n=y(this,U,"f").transaction(Z,"readwrite").objectStore(Z).delete(Me);n.onerror=()=>{t(n.error)},n.onsuccess=()=>{e()}})}async updateNonce(e){let r=/^[\x21-\x7E]+$/;if(typeof e!="string"||e.length===0)throw new Error("DPoP nonce must be a non-empty string");if(e.length>512)throw new Error("DPoP nonce exceeds maximum length of 512 characters");if(!r.test(e))throw new Error("DPoP nonce contains invalid characters");let i=await this.get();i&&(i.nonce=e,await this.set(i))}close(){y(this,U,"f")&&(y(this,U,"f").close(),R(this,U,null,"f"))}};Ee=new WeakMap,U=new WeakMap,Q=new WeakMap,le=new WeakMap,ke=new WeakMap,_e=new WeakMap,be=new WeakMap,Le=new WeakSet,ct=function(){return new Promise((e,t)=>{if(typeof indexedDB>"u"){t(new Error("IndexedDB is not available"));return}let r=indexedDB.open(y(this,Ee,"f"),Ot);r.onerror=()=>{t(r.error)},r.onsuccess=()=>{e(r.result)},r.onupgradeneeded=i=>{let n=i.target.result;i.oldVersion<1&&n.createObjectStore(Z)}})};$e=class{constructor(e){de.add(this),H.set(this,void 0),O.set(this,void 0),re.set(this,void 0),Te.set(this,new Map);let{issuerUrl:t,clientId:r,serverSupportedAlgorithms:i,requestedAlgorithm:n,strictStorage:s=!1}=e;if(typeof crypto>"u"||!crypto.subtle)throw new Error("DPoP requires Web Crypto API (crypto.subtle) which is not available in this environment.");if(!t)throw new Error("DPoP requires issuerUrl");if(!r)throw new Error("DPoP requires clientId");if(!i||!Array.isArray(i))throw new Error("DPoP requires serverSupportedAlgorithms array");R(this,re,i,"f");let c=ie.ES256;if(n!==void 0){if(!y(this,re,"f").includes(n))throw new Error(`Requested algorithm '${n}' is not supported by the server. Server supports: ${y(this,re,"f").join(", ")}`);c=n}R(this,H,c,"f"),R(this,O,new Ne(t.toString(),r,s),"f")}async init(){await y(this,O,"f").init();let e=await y(this,O,"f").get();e||(e={keys:await y(this,de,"m",lt).call(this)},await y(this,O,"f").set(e))}async flush(){await y(this,O,"f").flush()}async getAuthServerNonce(){let e=await y(this,O,"f").get();return e?.nonce}async updateAuthServerNonce(e){await y(this,O,"f").updateNonce(e)}getResourceServerNonce(e){return y(this,Te,"f").get(e)}updateResourceServerNonce(e,t){let i=/^[\x21-\x7E]+$/;typeof t!="string"||t.length===0||t.length>512||i.test(t)&&y(this,Te,"f").set(e,t)}async generateDPoPProof(e,t,r,i){let n={jti:crypto.randomUUID(),htm:t,htu:(()=>{let f=new URL(e);return f.origin+f.pathname})(),iat:Math.floor(Date.now()/1e3),...r!==void 0&&{ath:ye(await Bt(r))},...i!==void 0&&{nonce:i}},s=await y(this,O,"f").get();if(s===void 0)throw new Error("DPoP not initialized");let c=await crypto.subtle.exportKey("jwk",s.keys.publicKey),l={alg:y(this,H,"f"),typ:"dpop+jwt",jwk:{crv:c.crv,kty:c.kty,x:c.x,y:c.y}},d=new TextEncoder,h=`${ye(d.encode(JSON.stringify(l)))}.${ye(d.encode(JSON.stringify(n)))}`,u=await y(this,de,"m",dt).call(this,d.encode(h),s.keys.privateKey);return`${h}.${ye(u)}`}};H=new WeakMap,O=new WeakMap,re=new WeakMap,Te=new WeakMap,de=new WeakSet,lt=async function o(){let e=Ht[y(this,H,"f")];if(!e)throw new Error(`Unknown signature algorithm: ${y(this,H,"f")}`);try{return await crypto.subtle.generateKey(e,!1,["sign"])}catch(t){if(!(t instanceof DOMException&&t.name==="NotSupportedError")||y(this,H,"f")!==ie.EdDSA)throw t;let r=Vt.find(i=>y(this,re,"f").includes(i));if(!r)throw new Error("No supported algorithm available in this browser");return R(this,H,r,"f"),y(this,de,"m",o).call(this)}},dt=async function(e,t){let r=zt[y(this,H,"f")];if(!r)throw new Error(`Unknown signature algorithm: ${y(this,H,"f")}`);return await crypto.subtle.sign(r,t,e)}});function it(o=96){let e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",t=new Uint8Array(o);crypto.getRandomValues(t);let r="";for(let i=0;i<o;i++)r+=e[t[i]%e.length];return r}function nt(o){let e=new Uint8Array(o),t="";for(let r=0;r<e.byteLength;r++)t+=String.fromCharCode(e[r]);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"")}async function we(){let o=it(96),e=new TextEncoder,t=await crypto.subtle.digest("SHA-256",e.encode(o)),r=nt(t);return{verifier:o,challenge:r,method:"S256"}}async function Ue(o,e={}){let t=await fetch(o,{credentials:"include",...e,headers:{"Content-Type":"application/json",...e.headers||{}}}),r=await t.text(),i=null;try{i=r?JSON.parse(r):null}catch{}if(!t.ok){let n=new Error(i?.message||`Request failed (${t.status})`);throw n.status=t.status,n.body=i??r,n}return i}var ae=class{constructor(e){this.enclaveOrigin=e.homeOrkOrigin,this.voucherURL=e.voucherURL,this.signed_client_origin=e.signed_client_origin,this.vendorId=e.vendorId,this.isRunningLocal=e.isRunningLocal!=null?e.isRunningLocal:!1}enclaveClosed(){return this.enclaveWindow?this.enclaveWindow.closed:!0}getOrkUrl(){throw new Error("Method not implemented.")}async open(){switch(this._windowType){case _.Popup:return this.openPopUp();case _.Redirect:throw new Error("Method not implemented.");case _.Hidden:return this.openHiddenIframe()}}send(e){switch(this._windowType){case _.Popup:this.sendPostWindowMessage(e);break;case _.Redirect:throw new Error("Method not implemented.");case _.Hidden:this.sendPostWindowMessage(e);break}}async recieve(e){switch(this._windowType){case _.Popup:return this.waitForWindowPostMessage(e);case _.Redirect:throw new Error("Method not implemented.");case _.Hidden:return this.waitForWindowPostMessage(e)}}close(){switch(this._windowType){case _.Popup:this.closePopupEnclave();break;case _.Redirect:throw new Error("Method not implemented.");case _.Hidden:this.closeHiddenIframe();break;default:throw"Unknown window type"}}onerror(e){throw new Error("Method not implemented.")}async openPopUp(){let e=window.length/2-400,t=window.open(this.getOrkUrl(),"_blank",`width=800,height=800,left=${e}`);return t?(this.enclaveWindow=t,await this.waitForWindowPostMessage("pageLoaded"),!0):!1}async closeHiddenIframe(){window.document.querySelectorAll("iframe#heimdall").forEach(e=>e.remove())}async openHiddenIframe(){try{this.closeHiddenIframe();let e=document.createElement("iframe"),t=new Promise(s=>{e.onerror=()=>s(!1),e.addEventListener("error",()=>{s(!1)})});if(e.src=this.getOrkUrl().toString(),e.style.display="none",e.id="heimdall",e.setAttribute("aria-hidden","true"),this.isRunningLocal&&(e.allow="local-network-access"),document.body.appendChild(e),this.enclaveWindow=e.contentWindow,!this.enclaveWindow)return!1;let r=new Promise(async s=>{await this.waitForWindowPostMessage("pageLoaded"),s(!0)}),i=new Promise(s=>{setTimeout(()=>s(!1),4e3)});return await Promise.race([t,r,i])}catch{return!1}}closePopupEnclave(){this.enclaveWindow?.close()}async waitForWindowPostMessage(e){return new Promise(t=>{let r=i=>{let n=this.processEvent(i.data,i.origin,e);n.ok?(t(n.message),window.removeEventListener("message",r)):n.print&&console.error("[HEIMDALL] Recieved enclave error: "+n.error)};window.addEventListener("message",r,!1)})}sendPostWindowMessage(e){this.enclaveWindow?.postMessage(e,this.enclaveOrigin)}processEvent(e,t,r){if(t!==new URL(this.enclaveOrigin).origin)return{ok:!1,print:!1,error:"WRONG WINDOW SENT MESSAGE"};switch(e.type){case"newORKUrl":this.enclaveOrigin=new URL(e.url).origin;break;case"error":return this.onerror(e),{ok:!1,print:!1,error:"handled error"}}return r!==e.type?(console.log("[HEIMDALL] Received type{"+e.type+"} but waiting for type{"+r+"}"),{ok:!1,print:!1,error:"handled error"}):(console.log("[HEIMDALL] Correctly received type{"+e.type+"}"),{ok:!0,message:e.message})}},_;(function(o){o[o.Popup=0]="Popup",o[o.Redirect=1]="Redirect",o[o.Hidden=2]="Hidden"})(_||(_={}));var v=class o extends Uint8Array{static CreateFromArray(e){if(e.length==0)return new o;let t=e.reduce((i,n)=>i+4+n.length,0),r=this.Create(e[0],t);for(let i=1;i<e.length;i++)r.WriteValue(i,e[i]);return r}static Create(e,t,r=1){if(t<e.length+4)throw new Error("Not enough space to allocate requested data. Make sure to request more space in totalLength than length of InitialValue plus 4 bytes for length.");let i=4+t,n=new o(i),s=new DataView(n.buffer);s.setInt32(0,r,!0);let c=4;return s.setInt32(c,e.length,!0),c+=4,n.set(e,c),n}WriteValue(e,t){if(e<0)throw new Error("Index cannot be less than 0");if(e===0)throw new Error("Use CreateTideMemory to set value at index 0");if(this.length<4+t.length)throw new Error("Could not write to memory. Memory too small for this value");let r=new DataView(this.buffer),i=4;for(let s=0;s<e;s++){if(i+4>this.length)throw new RangeError("Index out of range.");let c=r.getInt32(i,!0);i+=4,i+=c}if(i+4+t.length>this.length)throw new RangeError("Not enough space to write value");if(r.getInt32(i,!0)!==0)throw new Error("Data has already been written to this index");r.setInt32(i,t.length,!0),i+=4,this.set(t,i)}GetValue(e){if(this.length<4)throw new Error("Insufficient data to read.");let t=new DataView(this.buffer,this.byteOffset,this.byteLength),r=4;for(let n=0;n<e;n++){if(r+4>this.length)throw new RangeError("Index out of range.");let s=t.getInt32(r,!0);r+=4+s}if(r+4>this.length)throw new RangeError("Index out of range.");let i=t.getInt32(r,!0);if(r+=4,r+i>this.length)throw new RangeError("Index out of range.");return this.subarray(r,r+i)}TryGetValue(e,t){try{return t.result=this.GetValue(e),!0}catch{return t.result=void 0,!1}}};function T(o){return new TextEncoder().encode(o)}function C(o){return new TextDecoder().decode(o)}function ot(o){if(o<0n)throw new Error("Negative BigInt values are not supported");let e=[],t=o;for(;t>0n;)e.push(Number(t&0xffn)),t=t>>8n;e.length===0&&e.push(0);let r=e.length,i=new Uint8Array(r);for(let n=0;n<Math.min(e.length,r);n++)i[n]=e[n];return i}function st(o){let e=0n;for(let t=o.length-1;t>=0;t--)e=e<<8n|BigInt(o[t]);return e}var F;(function(o){o[o.EXPLICIT=0]="EXPLICIT",o[o.IMPLICIT=1]="IMPLICIT"})(F||(F={}));var B;(function(o){o[o.PRIVATE=0]="PRIVATE",o[o.PUBLIC=1]="PUBLIC"})(B||(B={}));var $=class o{constructor(e){if(typeof e.version!="string")throw"Version is not a string";if(this.version=e.version,typeof e.contractId!="string")throw"ContractId is not a string";if(this.contractId=e.contractId,typeof e.modelId!="string")throw"ModelId is not a string";if(this.modelId=e.modelId,typeof e.keyId!="string")throw"KeyId is not a string";if(this.keyId=e.keyId,this.approvalType=e.approvalType,this.executionType=e.executionType,!e.params)throw"Params is null";this.params=e.params instanceof V?e.params:new V(e.params),this.dataToVerify=v.CreateFromArray([T(this.version),T(this.contractId),T(this.modelId),T(this.keyId),T(F[this.approvalType]),T(B[this.executionType]),this.params.toBytes()])}static from(e){let t=new v(e.length);t.set(e);let r=t.GetValue(0),i=C(r.GetValue(0));if(i!=o.latestVersion){if(i===ce.thisVersion)return ce.from(t);throw Error("Unknown policy version: "+i)}let n=C(r.GetValue(1)),s=C(r.GetValue(2)),c=C(r.GetValue(3)),l=F[C(r.GetValue(4))],d=B[C(r.GetValue(5))],h=new V(r.GetValue(6)),u=new o({version:i,contractId:n,modelId:s,keyId:c,approvalType:l,executionType:d,params:h}),f={result:void 0};return t.TryGetValue(1,f)&&(u.signature=f.result),u}toBytes(){let e=[v.CreateFromArray([T(this.version),T(this.contractId),T(this.modelId),T(this.keyId),T(F[this.approvalType]),T(B[this.executionType]),this.params.toBytes()])];return this.signature&&e.push(this.signature),v.CreateFromArray(e)}};$.latestVersion="2";var V=class o{constructor(e){e instanceof Uint8Array?this.entries=o.fromBytes(e):this.entries=new Map(e)}static fromBytes(e){let t=new Map,r=0,i={result:void 0},n=new v(e.length);for(n.set(e);n.TryGetValue(r,i);){let s=i.result.GetValue(0),c=C(s),l=i.result.GetValue(1),d=C(l),h=i.result.GetValue(2),u;switch(d){case"str":u=C(h);break;case"num":u=new DataView(h.buffer,h.byteOffset,h.byteLength).getInt32(0,!0);break;case"bnum":u=st(h);break;case"bln":u=h[0]===1;break;case"byt":u=new Uint8Array(h);break;default:throw new Error(`Could not find type of ${d}`)}t.set(c,u),r++}return t}tryGetParameter(e){try{return[!0,this.getParameter(e)]}catch{return[!1,null]}}getParameter(e){if(!this.entries.has(e))throw new Error(`Parameter '${e}' not found`);let t=this.entries.get(e),r=t instanceof Uint8Array?"Uint8Array":typeof t,i;if(t instanceof Uint8Array?i="Uint8Array":i=typeof t,!(typeof t=="string"&&t.constructor===String||typeof t=="number"&&t.constructor===Number||typeof t=="bigint"&&t.constructor===BigInt||typeof t=="boolean"&&t.constructor===Boolean||t instanceof Uint8Array))throw new Error(`Parameter '${e}' exists but has unexpected type '${r}'`);return t}toBytes(){let e=[];for(let[t,r]of this.entries){let i=T(t),n,s;if(typeof r=="string")n=T(r),s="str";else if(typeof r=="number"&&Number.isInteger(r)){let d=new ArrayBuffer(4);new DataView(d).setInt32(0,r,!0),n=new Uint8Array(d),s="num"}else if(typeof r=="bigint")n=ot(r),s="bnum";else if(typeof r=="boolean")n=new Uint8Array([r?1:0]),s="bln";else if(r instanceof Uint8Array)n=r,s="byt";else throw new Error(`Could not serialize key '${t}' of type '${typeof r}'`);let c=T(s),l=v.CreateFromArray([i,c,n]);e.push(l)}return v.CreateFromArray(e)}},ce=class o extends ${constructor(){super(...arguments),this.version=o.thisVersion}static from(e){let t=e.GetValue(0),r=C(t.GetValue(0));if(r!=o.thisVersion)throw Error("Dev error");let i=C(t.GetValue(1)),n=C(t.GetValue(2)),s=C(t.GetValue(3)),c=new V(t.GetValue(4)),l=new o({version:r,contractId:i,modelId:n,keyId:s,approvalType:F.EXPLICIT,executionType:B.PUBLIC,params:c}),d={result:void 0};return e.TryGetValue(1,d)&&(l.signature=d.result),l}toBytes(){let e=[v.CreateFromArray([T(o.thisVersion),T(this.contractId),T(this.modelId),T(this.keyId),this.params.toBytes()])];return this.signature&&e.push(this.signature),v.CreateFromArray(e)}};ce.thisVersion="1";var S=class o{constructor(e,t,r,i,n){this.name=e,this.version=t,this.authFlow=r,this.draft=new v(i.length),this.draft.set(i),this.dyanmicData=new v(n.length),this.dyanmicData.set(n),this.authorization=new v,this.authorizerCert=new v,this.authorizer=new v,this.expiry=Math.floor(Date.now()/1e3)+30,this.policy=new v}id(){return this.name+":"+this.version}replicate(){let e=new o(this.name,this.version,this.authFlow,this.draft,this.dyanmicData);return e.authorization=this.authorization,e.authorizerCert=this.authorizerCert,e.authorizer=this.authorizer,e.expiry=this.expiry,e.policy=this.policy,e}setNewDynamicData(e){return this.dyanmicData=new v(e.length),this.dyanmicData.set(e),this}setCustomExpiry(e){return this.expiry=Math.floor(Date.now()/1e3)+e,this}addAuthorizer(e){this.authorizer=new v(e.length),this.authorizer.set(e)}addAuthorizerCertificate(e){this.authorizerCert=new v(e.length),this.authorizerCert.set(e)}addAuthorization(e){return this.authorization=new v(e.length),this.authorization.set(e),this}addPolicy(e){return this.policy=new v(e.length),this.policy.set(e),this}hasPolicy(){return this.policy.length!=0}async getRequestInitDetails(){let e=new TextEncoder;return{creationTime:o.uint32ToUint8ArrayLE(Math.floor(Date.now()/1e3)),expireTime:o.uint32ToUint8ArrayLE(this.expiry),modelId:e.encode(this.id()),draftHash:new v(await crypto.subtle.digest("SHA-512",this.draft))}}addCreationSignature(e,t){return this.authorization=v.CreateFromArray([v.CreateFromArray([e,t]),new v]),this}isInitialized(){try{return this.authorization.GetValue(0).GetValue(0).length>0&&this.authorization.GetValue(0).GetValue(1).length==64}catch{return!1}}getUniqueId(){if(!this.isInitialized())throw"Must initialize request to generate unique id";let e=this.authorization.GetValue(0).GetValue(1);return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}getInitializedTime(){if(!this.isInitialized())throw"Must initialize request to get creation time";let e=this.authorization.GetValue(0).GetValue(0);return o.uint8ArrayToUint32LE(e)}getCurrentApprovalCount(){if(!this.isInitialized())throw"Must initialize request to get approval count";let e=0,t={result:void 0};for(;this.authorizer.TryGetValue(e,t);)e++;return e}getPolicy(){return $.from(this.policy)}removeApproval(e){if(!this.isInitialized()||this.getCurrentApprovalCount()==0)return!1;try{let t=0,r={result:new v},i={},n=[],s=[];for(;this.authorizer.TryGetValue(t,r);){let c=new ve(r.result);c.hasVuid(e)?i={index:t,value:c}:(n.push(r.result),s.push(this.authorization.GetValue(1).GetValue(t))),t++}if(i){let c=this.authorization.GetValue(0);return this.authorization=v.CreateFromArray([c,v.CreateFromArray(s)]),this.authorizer=v.CreateFromArray(n),!0}else return!1}catch(t){return console.error(t),!1}}encode(){if(this.authorizer==null)throw Error("Authorizer not added to request");if(this.authorizerCert==null)throw Error("Authorizer cert not provided");if(this.authorization==null)throw Error("Authorize this request first with an authorizer");let e=new TextEncoder,t=e.encode(this.name),r=e.encode(this.version),i=e.encode(this.authFlow),n=o.uint32ToUint8ArrayLE(this.expiry);return v.CreateFromArray([t,r,n,this.draft,i,this.dyanmicData,this.authorizer,this.authorization,this.authorizerCert,this.policy])}static decode(e){let t=new v(e.length);t.set(e);let r=new TextDecoder().decode(t.GetValue(0)),i=new TextDecoder().decode(t.GetValue(1));if(this._name!=null&&this._version!=null&&(r!=this._name||i!=this._version))throw Error("Name and Version in decoded data don't match this object's set name and version.");let n=o.uint8ArrayToUint32LE(t.GetValue(2)),s=t.GetValue(3),c=new TextDecoder().decode(t.GetValue(4)),l=t.GetValue(5),d=t.GetValue(6),h=t.GetValue(7),u=t.GetValue(8),f=t.GetValue(9),g=new this(r,i,c,s,l);return g.expiry=n,g.authorizer=d,g.authorization=h,g.authorizerCert=u,g.policy=f,g}static uint32ToUint8ArrayLE(e){let t=new Uint8Array(8);return t[0]=e&255,t[1]=e>>>8&255,t[2]=e>>>16&255,t[3]=e>>>24&255,t}static uint8ArrayToUint32LE(e){if(e.length!==8)throw new Error("Expected 8 bytes for a 64-bit value");return e[0]+(e[1]<<8)+(e[2]<<16)+e[3]*16777216}};var ve=class{constructor(e){if(!e||e.length===0)throw new Error("Doken constructor: received empty or null Uint8Array");let t=typeof e=="string"?e:C(e),r=t.split(".");if(r.length!==3)throw new Error(`Doken constructor: invalid token format. Expected 3 parts (header.payload.signature) but got ${r.length} parts in: "${t.substring(0,50)}..."`);try{let i=Dt(r[1]);this.payload=JSON.parse(i)}catch(i){throw new Error(`Doken constructor: failed to parse token payload. ${i instanceof Error?i.message:String(i)}. Raw payload part: "${r[1].substring(0,50)}..."`)}if(!this.payload||typeof this.payload!="object")throw new Error(`Doken constructor: parsed payload is not a valid object. Got type: ${typeof this.payload}`)}hasResourceAccessRole(e,t){if(!e)throw new Error("hasResourceAccessRole: role parameter is empty or undefined");if(!t)throw new Error("hasResourceAccessRole: client parameter is empty or undefined");return!this.payload.resource_access||!this.payload.resource_access[t]||!Array.isArray(this.payload.resource_access[t].roles)?!1:this.payload.resource_access[t].roles.includes(e)}hasRealmAccessRole(e){if(!e)throw new Error("hasRealmAccessRole: role parameter is empty or undefined");return!this.payload.realm_access||!Array.isArray(this.payload.realm_access.roles)?!1:this.payload.realm_access.roles.includes(e)}hasVuid(e){if(!e)throw new Error("hasVuid: vuid cannot be null");if(!this.payload.vuid)throw new Error("hasVuid: cannot find vuid in paylod");return this.payload.vuid===e}};function Dt(o){let e=o.replaceAll("-","+").replaceAll("_","/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("Input is not of the correct length.")}try{return xt(e)}catch{return atob(e)}}function xt(o){return decodeURIComponent(atob(o).replace(/(.)/g,(e,t)=>{let r=t.charCodeAt(0).toString(16).toUpperCase();return r.length<2&&(r="0"+r),"%"+r}))}var E;(function(o){o[o.Closed=0]="Closed",o[o.InitializingIFrame=1]="InitializingIFrame",o[o.FailedIFrameInitialization=2]="FailedIFrameInitialization",o[o.InitializingPopUp=3]="InitializingPopUp",o[o.FailedPopUpInitialization=4]="FailedPopUpInitialization",o[o.Ready=5]="Ready"})(E||(E={}));var q=class extends ae{constructor(){super(...arguments),this.name="request",this.state=E.Closed,this._windowType=_.Hidden,this.initDone=this.recieve("init done")}init(e){if(!e.doken)throw"Doken not provided";this.doken=e.doken;let t=Mt(this.doken);if(t["t.uho"]&&(this.enclaveOrigin=t["t.uho"]),this.dokenRefreshCallback=e.dokenRefreshCallback,this.requireReloginCallback=e.requireReloginCallback,this.state===E.Closed)return this._windowType===_.Hidden&&(this.recieve("hidden enclave").then(r=>this.handleHiddenEnclaveResponse(r)),this.checkEnclaveOpen()),this}async handleHiddenEnclaveResponse(e){e=="session key mismatch"?(this.close(),console.log("[HEIMDALL] Session key mismatch between enclave and doken. Reinitiating login"),this.requireReloginCallback(),this.state=E.Closed):e=="storage issue"&&(this.close(),console.log("[HEIMDALL] Storage issue found on hidden iframe. Trying popup window next"),this.state=E.FailedIFrameInitialization,this.checkEnclaveOpen()),this.recieve("hidden enclave").then(t=>this.handleHiddenEnclaveResponse(t))}getOrkUrl(){let e=new URL(this.enclaveOrigin);return e.searchParams.set("hidden",this._windowType==_.Hidden?"true":"false"),e.searchParams.set("vendorId",this.vendorId),e.searchParams.set("origin",encodeURIComponent(window.location.origin)),e.searchParams.set("originsig",encodeURIComponent(this.signed_client_origin)),e.searchParams.set("voucherURL",encodeURIComponent(this.voucherURL)),e.searchParams.set("type",this.name),e}checkEnclaveOpen(){if(this.enclaveClosed()){switch(this.state){case E.InitializingIFrame:case E.InitializingPopUp:return;case E.Closed:this._windowType===_.Hidden?this.state=E.InitializingIFrame:this._windowType===_.Popup&&(this.state=E.InitializingPopUp);break;case E.FailedIFrameInitialization:this.state=E.InitializingPopUp,this._windowType=_.Popup;break;case E.FailedPopUpInitialization:console.warn("[HEIMDALL] Failed to initialize the popup enclave"),window.alert("There was an issue opening the fallback popup on this page. Please enable popups or let the administrator know about this problem. For more information, visit https://tide.org/browserwindow");return;case E.Ready:console.error("[HEIMDALL] State says ready but no enclave open. Trying popup again"),this.state=E.InitializingPopUp,this._windowType=_.Popup;break}this.initDone=this.recieve("init done"),console.log(`[HEIMDALL] Attempting to open ${_[this._windowType]} window`),this.open().then(e=>{e?(this.send({type:"init",message:{doken:this.doken}}),console.log(`[HEIMDALL] Successfully opened ${_[this._windowType]} window`),this.state=E.Ready):this.state===E.InitializingIFrame?(this.state=E.FailedIFrameInitialization,console.error("Error opening enclave of type: "+_[this._windowType]+". Trying popup."),this.checkEnclaveOpen()):this.state===E.InitializingPopUp&&(this.state=E.FailedIFrameInitialization,console.error("Error opening enclave of type: "+_[this._windowType]))})}}async initializeRequest(e){let t=S.decode(e),r=await t.getRequestInitDetails(),i=new S("TideRequestInitialization","1","Doken:1",v.CreateFromArray([r.creationTime,r.expireTime,r.modelId,r.draftHash]),new v),n=(await this.execute(i.encode()))[0];return t.addCreationSignature(r.creationTime,n).encode()}async execute(e,t=!1){this.checkEnclaveOpen(),await this.initDone;let r=this.recieve("sign request completed");this.send({type:"request",message:{flow:"sign",request:e,waitForAll:t}});let i=await r;if(!Array.isArray(i))throw"Expecting request completed data to be an array, not"+i;if(!i.every(n=>n instanceof Uint8Array))throw"Expecting all entries in response to be Uint8Arrays";return i}async decrypt(e){this.checkEnclaveOpen(),await this.initDone;let t=this.recieve("decrypt request completed");this.send({type:"request",message:{flow:"decrypt",request:e}});let r=await t;if(!Array.isArray(r))throw"Expecting request completed data to be an array, not"+r;if(!r.every(i=>i instanceof Uint8Array))throw"Expecting all entries in response to be Uint8Arrays";return r}async encrypt(e){this.checkEnclaveOpen(),await this.initDone;let t=this.recieve("encrypt request completed");this.send({type:"request",message:{flow:"encrypt",request:e}});let r=await t;if(!Array.isArray(r))throw"Expecting request completed data to be an array, not"+r;if(!r.every(i=>i instanceof Uint8Array))throw"Expecting all entries in response to be Uint8Arrays";return r}async updateDoken(e){this.doken=e,this.send({type:"doken refresh",message:{doken:this.doken}})}async onerror(e){if(typeof e.message=="string")switch(e.message){case"expired":if(!this.dokenRefreshCallback){console.error("[HEIMDALL] Doken on enclave has expired but there is no Doken Refresh Callback registered");return}console.log("[HEIMDALL] Refreshing doken"),this.doken=await this.dokenRefreshCallback(),this.send({type:"doken refresh",message:{doken:this.doken}});break;default:throw this.close(),new Error("[HEIMDALL] Recieved enclave error: "+e.message)}}};function Mt(o){let[e,t]=o.split(".");if(typeof t!="string")throw new Error("Unable to decode token, payload not found.");let r;try{r=Lt(t)}catch(i){throw new Error("Unable to decode token, payload is not a valid Base64URL value. Error: "+i)}try{return JSON.parse(r)}catch(i){throw new Error("Unable to decode token, payload is not a valid JSON value. Error: "+i)}}function Lt(o){let e=o.replace(/-/g,"+").replace(/_/g,"/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("Input is not of the correct length.")}try{return Nt(e)}catch{return atob(e)}}function Nt(o){return decodeURIComponent(atob(o).replace(/(.)/g,(e,t)=>{let r=t.charCodeAt(0).toString(16).toUpperCase();return r.length<2&&(r="0"+r),"%"+r}))}var Y=class extends q{constructor(){super(...arguments),this.name="approvalNew",this._windowType=_.Popup}init(e){return super.init(e)}async approve(e){this.checkEnclaveOpen(),await this.initDone;let t=this.recieve("approvals");this.send({type:"approvalRequests",message:{requests:e}});let r=await t;if(!Array.isArray(r))throw"Expecting request completed data to be an array, not"+r;if(!r.every(i=>De.isOperatorApprovalResponse(i)))throw"Expecting all entries in response to be OperatorApprovalResponse";return this.close(),r}},Re=class{},De=class extends Re{static isOperatorApprovalResponse(e){return e!=null&&typeof e.id=="string"&&(e.request instanceof Uint8Array||e.request==null)&&Object.values(xe).includes(e.status)}},xe;(function(o){o.Approved="approved",o.Denied="denied",o.Pending="pending"})(xe||(xe={}));var a=function(o,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?o!==e||!r:!e.has(o))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(o):r?r.value:e.get(o)},W=function(o,e,t,r,i){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!i)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?o!==e||!i:!e.has(o))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?i.call(o,t):i?i.value=t:e.set(o,t),t},p,J,D,fe,pe,z,te,b,A,P,Ie,ht,ut,ft,_t,He,pt,ze,je,bt,Tt,Ae,he,Ve,G,gt,Fe,j,Be,mt,Et,At,Pe,ge,L,Je,K,Ke,Ct,We,wt,ee,It,Xe,Ye,Wt="application/json",Qe=class{constructor(e){if(p.add(this),J.set(this,[]),D.set(this,void 0),fe.set(this,!0),pe.set(this,void 0),z.set(this,a(this,p,"m",Je).call(this,console.info)),te.set(this,a(this,p,"m",Je).call(this,console.warn)),b.set(this,{enable:!0,callbackList:[],interval:5}),A.set(this,void 0),P.set(this,void 0),this.didInitialize=!1,this.authenticated=!1,this.loginRequired=!1,this.responseMode="fragment",this.responseType="code",this.flow="standard",this.timeSkew=null,this.silentCheckSsoFallback=!0,this.pkceMethod="S256",this.enableLogging=!1,this.logoutMethod="GET",this.messageReceiveTimeout=1e4,this.init=async(t={})=>{var r,i,n;if(this.didInitialize)throw new Error("A 'TideCloak' instance can only be initialized once.");this.didInitialize=!0,W(this,pe,Qt(),"f");let s=["default","cordova","cordova-native"];if(typeof t.adapter=="string"&&s.includes(t.adapter)?W(this,D,a(this,p,"m",Ie).call(this,t.adapter),"f"):typeof t.adapter=="object"?W(this,D,t.adapter,"f"):"Cordova"in window||"cordova"in window?W(this,D,a(this,p,"m",Ie).call(this,"cordova"),"f"):W(this,D,a(this,p,"m",Ie).call(this,"default"),"f"),typeof t.useNonce<"u"&&W(this,fe,t.useNonce,"f"),typeof t.checkLoginIframe<"u"&&(a(this,b,"f").enable=t.checkLoginIframe),t.checkLoginIframeInterval&&(a(this,b,"f").interval=t.checkLoginIframeInterval),t.onLoad==="login-required"&&(this.loginRequired=!0),t.responseMode)if(t.responseMode==="query"||t.responseMode==="fragment")this.responseMode=t.responseMode;else throw new Error("Invalid value for responseMode");if(t.flow){switch(t.flow){case"standard":this.responseType="code";break;case"implicit":this.responseType="id_token token";break;case"hybrid":this.responseType="code id_token token";break;default:throw new Error("Invalid value for flow")}this.flow=t.flow}if(typeof t.timeSkew=="number"&&(this.timeSkew=t.timeSkew),t.redirectUri&&(this.redirectUri=t.redirectUri),t.silentCheckSsoRedirectUri&&(this.silentCheckSsoRedirectUri=t.silentCheckSsoRedirectUri),typeof t.silentCheckSsoFallback=="boolean"&&(this.silentCheckSsoFallback=t.silentCheckSsoFallback),typeof t.pkceMethod<"u"){if(t.pkceMethod!=="S256"&&t.pkceMethod!==!1)throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${t.pkceMethod}.`);this.pkceMethod=t.pkceMethod}if(typeof t.enableLogging=="boolean"&&(this.enableLogging=t.enableLogging),t.logoutMethod==="POST"&&(this.logoutMethod="POST"),typeof t.scope=="string"&&(this.scope=t.scope),typeof t.messageReceiveTimeout=="number"&&t.messageReceiveTimeout>0&&(this.messageReceiveTimeout=t.messageReceiveTimeout),t.useDPoP&&(this.useDPoP=t.useDPoP),await a(this,p,"m",_t).call(this),((r=this.useDPoP)===null||r===void 0?void 0:r.mode)==="strict"&&(!this.dpopSigningAlgValuesSupported||this.dpopSigningAlgValuesSupported.length===0))throw new Error("DPoP is set to strict mode but the server does not advertise DPoP support (dpop_signing_alg_values_supported is missing or empty).");if(this.useDPoP&&(!((i=this.dpopSigningAlgValuesSupported)===null||i===void 0)&&i.length)){let c=a(this,p,"m",je).call(this);if(!c)throw new Error("Cannot initialize DPoP: issuer URL is not available. Ensure authServerUrl and realm are configured, or use OIDC provider mode with a valid issuer.");if(!this.clientId)throw new Error("Cannot initialize DPoP: clientId is not configured.");let{DPoPSignatureProvider:l,BrowserSignatureAlgs:d}=await Promise.resolve().then(()=>(Oe(),qe));W(this,A,new l({issuerUrl:new URL(c),clientId:this.clientId,serverSupportedAlgorithms:this.dpopSigningAlgValuesSupported,requestedAlgorithm:this.useDPoP.alg?d[this.useDPoP.alg]:d.ES256}),"f"),await a(this,A,"f").init(),a(this,z,"f").call(this,"[TIDECLOAK] DPoP initialized")}return await a(this,p,"m",bt).call(this),await a(this,p,"m",Tt).call(this,t),(n=this.onReady)===null||n===void 0||n.call(this,this.authenticated),this.token&&this.initRequestEnclave(),document.addEventListener("click",()=>{a(this,p,"m",At).call(this)}),this.authenticated},this.login=t=>a(this,D,"f").login(t),this.createLoginUrl=async t=>{let r=vt(),i=vt(),n=a(this,D,"f").redirectUri(t),s={state:r,nonce:i,redirectUri:n,loginOptions:t};t?.prompt&&(s.prompt=t.prompt);let c=t?.action==="register"?this.endpoints.register():this.endpoints.authorize(),l=t?.scope||this.scope,d=l?l.split(" "):[];d.includes("openid")||d.unshift("openid"),l=d.join(" ");let h=new URLSearchParams([["client_id",this.clientId],["redirect_uri",n],["state",r],["response_mode",this.responseMode],["response_type",this.responseType],["scope",l]]);if(a(this,fe,"f")&&h.append("nonce",i),t?.prompt&&h.append("prompt",t.prompt),typeof t?.maxAge=="number"&&h.append("max_age",t.maxAge.toString()),t?.loginHint&&h.append("login_hint",t.loginHint),t?.idpHint&&h.append("kc_idp_hint",t.idpHint),t?.action&&t.action!=="register"&&h.append("kc_action",t.action),t?.locale&&h.append("ui_locales",t.locale),t?.acr&&h.append("claims",Gt(t.acr)),t?.acrValues&&h.append("acr_values",t.acrValues),this.pkceMethod)try{let u=jt(96),f=await Jt(this.pkceMethod,u);s.pkceCodeVerifier=u,h.append("code_challenge",f),h.append("code_challenge_method",this.pkceMethod)}catch(u){throw new Error("Failed to generate PKCE challenge.",{cause:u})}return a(this,pe,"f").add(s),`${c}?${h.toString()}`},this.logout=async t=>{var r;return await((r=a(this,A,"f"))===null||r===void 0?void 0:r.flush()),a(this,D,"f").logout(t)},this.createLogoutUrl=t=>{var r;let i=(r=t?.logoutMethod)!==null&&r!==void 0?r:this.logoutMethod,n=this.endpoints.logout();if(i==="POST")return n;let s=new URLSearchParams([["client_id",this.clientId],["post_logout_redirect_uri",a(this,D,"f").redirectUri(t)]]);return this.idToken&&s.append("id_token_hint",this.idToken),`${n}?${s.toString()}`},this.register=t=>a(this,D,"f").register(t),this.createRegisterUrl=t=>this.createLoginUrl({...t,action:"register"}),this.createAccountUrl=t=>{let r=a(this,p,"m",L).call(this);if(!r)throw new Error("Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.");let i=new URLSearchParams([["referrer",this.clientId],["referrer_uri",a(this,D,"f").redirectUri(t)]]);return`${r}/account?${i.toString()}`},this.accountManagement=()=>a(this,D,"f").accountManagement(),this.hasRealmRole=t=>{let r=this.realmAccess;return!!r&&r.roles.indexOf(t)>=0},this.hasResourceRole=(t,r)=>{if(!this.resourceAccess)return!1;let i=this.resourceAccess[r||this.clientId];return!!i&&i.roles.indexOf(t)>=0},this.loadUserProfile=async()=>{let t=a(this,p,"m",L).call(this);if(!t)throw new Error("Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.");let r=`${t}/account`,i=await X(r,{headers:[kt(this.token)]});return this.profile=i},this.loadUserInfo=async()=>{let t=this.endpoints.userinfo(),r=await X(t,{headers:[kt(this.token)]});return this.userInfo=r},this.isTokenExpired=t=>{if(!this.tokenParsed||!this.refreshToken&&this.flow!=="implicit")throw new Error("Not authenticated");if(this.timeSkew==null)return a(this,z,"f").call(this,"[TIDECLOAK] Unable to determine if token is expired as timeskew is not set"),!0;if(typeof this.tokenParsed.exp!="number")return!1;let r=this.tokenParsed.exp-Math.ceil(new Date().getTime()/1e3)+this.timeSkew;if(t){if(isNaN(t))throw new Error("Invalid minValidity");r-=t}return r<0},this.updateToken=async t=>{var r,i;if(!this.refreshToken)throw new Error("Unable to update token, no refresh token available.");t=t||5,a(this,b,"f").enable&&await a(this,p,"m",he).call(this);let n=!1;if(t===-1?(n=!0,a(this,z,"f").call(this,"[TIDECLOAK] Refreshing token: forced refresh")):(!this.tokenParsed||this.isTokenExpired(t))&&(n=!0,a(this,z,"f").call(this,"[TIDECLOAK] Refreshing token: token expired")),!n)return!1;let{promise:s,resolve:c,reject:l}=Promise.withResolvers();if(a(this,J,"f").push({resolve:c,reject:l}),a(this,J,"f").length===1){let d=this.endpoints.token(),h=new Date().getTime();try{let u=await a(this,p,"m",Et).call(this,d,this.refreshToken,this.clientId);a(this,z,"f").call(this,"[TIDECLOAK] Token refreshed"),h=(h+new Date().getTime())/2,a(this,p,"m",ge).call(this,u.access_token,u.refresh_token,u.id_token,h,u.doken),(r=this.onAuthRefreshSuccess)===null||r===void 0||r.call(this);for(let f=a(this,J,"f").pop();f!=null;f=a(this,J,"f").pop())f.resolve(!0)}catch(u){a(this,te,"f").call(this,"[TIDECLOAK] Failed to refresh token"),u instanceof oe&&u.response.status===400&&this.clearToken(),(i=this.onAuthRefreshError)===null||i===void 0||i.call(this);for(let f=a(this,J,"f").pop();f!=null;f=a(this,J,"f").pop())f.reject(u)}}return await s},this.clearToken=()=>{var t;this.token&&(a(this,p,"m",ge).call(this),(t=this.onAuthLogout)===null||t===void 0||t.call(this),this.loginRequired&&this.login())},this.secureFetch=async(t,r={})=>{var i,n;let s=a(this,A,"f");if(s&&this.authenticated&&this.token){if(!(new Headers(r.headers).get("Authorization")===`Bearer ${this.token}`))return fetch(t,r);let d=t instanceof URL?t.href:t.toString(),h=new URL(d).origin,u=(i=r.method)!==null&&i!==void 0?i:"GET",f=s.getResourceServerNonce(h),g=await s.generateDPoPProof(d,u,this.token,f),m=new Headers(r.headers);m.set("Authorization",`DPoP ${this.token}`),m.set("DPoP",g);let k=await fetch(t,{...r,headers:m}),w=k.headers.get("DPoP-Nonce");if(w&&s.updateResourceServerNonce(h,w),k.status===401&&w){let I=(n=k.headers.get("WWW-Authenticate"))!==null&&n!==void 0?n:"";if(I.includes("DPoP")&&I.includes('error="use_dpop_nonce"')){let se=await s.generateDPoPProof(d,u,this.token,w),N=new Headers(r.headers);N.set("Authorization",`DPoP ${this.token}`),N.set("DPoP",se);let M=await fetch(t,{...r,headers:N}),me=M.headers.get("DPoP-Nonce");return me&&s.updateResourceServerNonce(h,me),M}}return k}else return fetch(t,r)},typeof e!="string"&&!ue(e))throw new Error("The 'TideCloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.");if(ue(e)){let t="oidcProvider"in e?["clientId"]:["url","realm","clientId"];for(let r of t)if(!(r in e))throw new Error(`The configuration object is missing the required '${r}' property.`)}globalThis.isSecureContext||a(this,te,"f").call(this,`[TIDECLOAK] TideCloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.
Continuing to run your application insecurely will lead to unexpected behavior and breakage.

For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts`),W(this,P,e,"f")}async ensureTokenReady(){this.tokenParsed&&this.isTokenExpired()&&await this.updateToken(-1)}initRequestEnclave(){if(!this.doken)throw new Error("[TIDECLOAK] No doken found");if(!this.dokenParsed)throw new Error("[TIDECLOAK] Token not parsed");this.requestEnclave||(this.requestEnclave=new q({homeOrkOrigin:this.dokenParsed["t.uho"],signed_client_origin:a(this,P,"f").clientOriginAuth,vendorId:a(this,P,"f").vendorId,voucherURL:a(this,p,"m",Pe).call(this),isRunningLocal:new URL(a(this,p,"m",Pe).call(this)).hostname==="localhost"}).init({doken:this.doken,dokenRefreshCallback:async()=>{if(await this.ensureTokenReady(),!this.doken)throw new Error("[TIDECLOAK] No doken found");return this.doken},requireReloginCallback:async()=>{await this.login({idpHint:"tide",prompt:"login",redirectUri:window.location.href})}}))}initApprovalEnclave(){if(!this.doken)throw new Error("[TIDECLOAK] No doken found");if(!this.dokenParsed)throw new Error("[TIDECLOAK] Token not parsed");this.approvalEnclave||(this.approvalEnclave=new Y({homeOrkOrigin:this.dokenParsed["t.uho"],signed_client_origin:a(this,P,"f").clientOriginAuth,vendorId:a(this,P,"f").vendorId,voucherURL:a(this,p,"m",Pe).call(this)}).init({doken:this.doken,dokenRefreshCallback:async()=>{if(await this.ensureTokenReady(),!this.doken)throw new Error("[TIDECLOAK] No doken found");return this.doken},requireReloginCallback:async()=>{await this.login({idpHint:"tide",prompt:"login",redirectUri:window.location.href})}}))}async encrypt(e){if(await this.ensureTokenReady(),!Array.isArray(e))throw new Error("Pass array as parameter");if(!this.tokenParsed)throw new Error("Not authenticated");let t=e.map(i=>{if(!ue(i))throw new Error("All entries must be an object to encrypt");for(let n of["data","tags"])if(!i[n])throw new Error(`The configuration object is missing the required '${n}' property.`);if(!Array.isArray(i.tags))throw new Error("tags must be provided as a string array in object to encrypt");if(typeof i.data!="string"&&!(i.data instanceof Uint8Array))throw new Error("data must be provided as string or Uint8Array in object to encrypt");for(let n of i.tags){if(typeof n!="string")throw new Error("tags must be provided as an array of strings");if(!this.hasRealmRole(`_tide_${n}.selfencrypt`))throw new Error(`User has not been given any access to '${n}'`)}return{data:typeof i.data=="string"?er(i.data):i.data,tags:i.tags,isRaw:typeof i.data!="string"}});return this.initRequestEnclave(),(await this.requestEnclave.encrypt(t)).map((i,n)=>t[n].isRaw?i:Pt(i))}async createTideRequest(e){return await this.ensureTokenReady(),this.initRequestEnclave(),await this.requestEnclave.initializeRequest(e)}async requestTideOperatorApproval(e){return await this.ensureTokenReady(),this.initApprovalEnclave(),await this.approvalEnclave.approve(e)}async executeSignRequest(e,t=!1){return await this.ensureTokenReady(),this.initRequestEnclave(),this.requestEnclave.execute(e,t)}async decrypt(e){if(await this.ensureTokenReady(),!Array.isArray(e))throw new Error("Pass array as parameter");if(!this.tokenParsed)throw new Error("Not authenticated");let t=e.map(i=>{if(!ue(i))throw new Error("All entries must be an object to decrypt");for(let n of["encrypted","tags"])if(!i[n])throw new Error(`The configuration object is missing the required '${n}' property.`);if(!Array.isArray(i.tags))throw new Error("tags must be provided as a string array in object to decrypt");if(typeof i.encrypted!="string"&&!(i.encrypted instanceof Uint8Array))throw new Error("encrypted must be provided as string or Uint8Array in object to decrypt");for(let n of i.tags){if(typeof n!="string")throw new Error("tags must be provided as an array of strings");if(!this.hasRealmRole(`_tide_${n}.selfdecrypt`))throw new Error(`User has not been given any access to '${n}'`)}return{encrypted:typeof i.encrypted=="string"?Zt(i.encrypted):i.encrypted,tags:i.tags,isRaw:typeof i.encrypted!="string"}});return this.initRequestEnclave(),(await this.requestEnclave.decrypt(t)).map((i,n)=>t[n].isRaw?i:tr(i))}};J=new WeakMap,D=new WeakMap,fe=new WeakMap,pe=new WeakMap,z=new WeakMap,te=new WeakMap,b=new WeakMap,A=new WeakMap,P=new WeakMap,p=new WeakSet,Ie=function(e){if(e==="default")return a(this,p,"m",ht).call(this);if(e==="cordova")return a(this,b,"f").enable=!1,a(this,p,"m",ut).call(this);if(e==="cordova-native")return a(this,b,"f").enable=!1,a(this,p,"m",ft).call(this);throw new Error("invalid adapter type: "+e)},ht=function(){let e=t=>t?.redirectUri||this.redirectUri||globalThis.location.href;return{login:async t=>(window.location.assign(await this.createLoginUrl(t)),await new Promise(()=>{})),logout:async t=>{var r;if(((r=t?.logoutMethod)!==null&&r!==void 0?r:this.logoutMethod)==="GET"){window.location.replace(this.createLogoutUrl(t));return}let n=document.createElement("form");n.setAttribute("method","POST"),n.setAttribute("action",this.createLogoutUrl(t)),n.style.display="none";let s={id_token_hint:this.idToken,client_id:this.clientId,post_logout_redirect_uri:e(t)};for(let[c,l]of Object.entries(s)){let d=document.createElement("input");d.setAttribute("type","hidden"),d.setAttribute("name",c),d.setAttribute("value",l),n.appendChild(d)}document.body.appendChild(n),n.submit()},register:async t=>(window.location.assign(await this.createRegisterUrl(t)),await new Promise(()=>{})),accountManagement:async()=>{let t=this.createAccountUrl();if(typeof t<"u")window.location.href=t;else throw new Error("Not supported by the OIDC server");return await new Promise(()=>{})},redirectUri:e}},ut=function(){let e=(s,c,l)=>window.cordova&&window.cordova.InAppBrowser?window.cordova.InAppBrowser.open(s,c,l):window.open(s,c,l),t=s=>s&&s.cordovaOptions?Object.keys(s.cordovaOptions).reduce((c,l)=>(c[l]=s.cordovaOptions[l],c),{}):{},r=s=>Object.keys(s).reduce((c,l)=>(c.push(l+"="+s[l]),c),[]).join(","),i=s=>{let c=t(s);return c.location="no",s&&s.prompt==="none"&&(c.hidden="yes"),r(c)},n=()=>this.redirectUri||"http://localhost";return{login:async s=>{let c=i(s),l=await this.createLoginUrl(s),d=e(l,"_blank",c),h=!1,u=!1;function f(){u=!0,d.close()}return await new Promise((g,m)=>{d.addEventListener("loadstart",async k=>{if(k.url.indexOf(n())===0){let w=a(this,p,"m",G).call(this,k.url);try{await a(this,p,"m",j).call(this,w),g()}catch(I){m(I)}f(),h=!0}}),d.addEventListener("loaderror",async k=>{if(!h)if(k.url.indexOf(n())===0){let w=a(this,p,"m",G).call(this,k.url);try{await a(this,p,"m",j).call(this,w),g()}catch(I){m(I)}f(),h=!0}else m(new Error("Unable to process login.")),f()}),d.addEventListener("exit",function(k){u||m(new Error("User closed the login window."))})})},logout:async s=>{let c=this.createLogoutUrl(s),l=e(c,"_blank","location=no,hidden=yes,clearcache=yes"),d=!1;l.addEventListener("loadstart",h=>{h.url.indexOf(n())===0&&l.close()}),l.addEventListener("loaderror",h=>{h.url.indexOf(n())===0||(d=!0),l.close()}),await new Promise((h,u)=>{l.addEventListener("exit",()=>{d?u(new Error("User closed the login window.")):(this.clearToken(),h())})})},register:async s=>{let c=await this.createRegisterUrl(),l=i(s),d=e(c,"_blank",l);await new Promise((u,f)=>{d.addEventListener("loadstart",async g=>{if(g.url.indexOf(n())===0){d.close();let m=a(this,p,"m",G).call(this,g.url);try{await a(this,p,"m",j).call(this,m),u()}catch(k){f(k)}}})})},accountManagement:async()=>{let s=this.createAccountUrl();if(typeof s<"u"){let c=e(s,"_blank","location=no");c.addEventListener("loadstart",function(l){l.url.indexOf(n())===0&&c.close()})}else throw new Error("Not supported by the OIDC server")},redirectUri:()=>n()}},ft=function(){return{login:async e=>{let t=await this.createLoginUrl(e);await new Promise((r,i)=>{universalLinks.subscribe("keycloak",async n=>{universalLinks.unsubscribe("keycloak"),window.cordova.plugins.browsertab.close();let s=a(this,p,"m",G).call(this,n.url);try{await a(this,p,"m",j).call(this,s),r()}catch(c){i(c)}}),window.cordova.plugins.browsertab.openUrl(t)})},logout:async e=>{let t=this.createLogoutUrl(e);await new Promise(r=>{universalLinks.subscribe("keycloak",()=>{universalLinks.unsubscribe("keycloak"),window.cordova.plugins.browsertab.close(),this.clearToken(),r()}),window.cordova.plugins.browsertab.openUrl(t)})},register:async e=>{let t=await this.createRegisterUrl(e);await new Promise((r,i)=>{universalLinks.subscribe("keycloak",async n=>{universalLinks.unsubscribe("keycloak"),window.cordova.plugins.browsertab.close();let s=a(this,p,"m",G).call(this,n.url);try{await a(this,p,"m",j).call(this,s),r()}catch(c){i(c)}}),window.cordova.plugins.browsertab.openUrl(t)})},accountManagement:async()=>{let e=this.createAccountUrl();if(typeof e<"u")window.cordova.plugins.browsertab.openUrl(e);else throw new Error("Not supported by the OIDC server")},redirectUri:e=>e&&e.redirectUri?e.redirectUri:this.redirectUri?this.redirectUri:"http://localhost"}},_t=async function(){if(typeof a(this,P,"f")=="string"){let e=await or(a(this,P,"f"));this.authServerUrl=e["auth-server-url"],this.realm=e.realm,this.clientId=e.resource,await a(this,p,"m",He).call(this)}else this.clientId=a(this,P,"f").clientId,"oidcProvider"in a(this,P,"f")?await a(this,p,"m",pt).call(this,a(this,P,"f").oidcProvider):(this.authServerUrl=a(this,P,"f").url,this.realm=a(this,P,"f").realm,await a(this,p,"m",He).call(this))},He=async function(){if(this.useDPoP){let e=a(this,p,"m",je).call(this);if(!e)a(this,te,"f").call(this,"[TIDECLOAK] Cannot fetch OIDC metadata: issuer URL is not available");else{let t=`${Ge(e)}/.well-known/openid-configuration`;try{let r=await yt(t);this.dpopSigningAlgValuesSupported=r.dpop_signing_alg_values_supported?r.dpop_signing_alg_values_supported:void 0}catch(r){a(this,te,"f").call(this,"[TIDECLOAK] Failed to fetch OIDC metadata for DPoP configuration: "+(r instanceof Error?r.message:r))}}}this.endpoints={authorize:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/auth",token:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/token",logout:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/logout",checkSessionIframe:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/login-status-iframe.html",thirdPartyCookiesIframe:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/3p-cookies/step1.html",register:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/registrations",userinfo:()=>a(this,p,"m",L).call(this)+"/protocol/openid-connect/userinfo"}},pt=async function(e){if(typeof e=="string"){let t=`${Ge(e)}/.well-known/openid-configuration`,r=await yt(t);a(this,p,"m",ze).call(this,r)}else a(this,p,"m",ze).call(this,e)},ze=function(e){this.dpopSigningAlgValuesSupported=e.dpop_signing_alg_values_supported,this.issuer=e.issuer,this.endpoints={authorize(){return e.authorization_endpoint},token(){return e.token_endpoint},logout(){if(!e.end_session_endpoint)throw new Error("Not supported by the OIDC server");return e.end_session_endpoint},checkSessionIframe(){if(!e.check_session_iframe)throw new Error("Not supported by the OIDC server");return e.check_session_iframe},register(){throw new Error('Redirection to "Register user" page not supported in standard OIDC mode')},userinfo(){if(!e.userinfo_endpoint)throw new Error("Not supported by the OIDC server");return e.userinfo_endpoint}}},je=function(){return this.issuer?this.issuer:a(this,p,"m",L).call(this)||void 0},bt=async function(){if(!a(this,b,"f").enable&&!this.silentCheckSsoRedirectUri||typeof this.endpoints.thirdPartyCookiesIframe!="function")return;let e=document.createElement("iframe");e.setAttribute("src",this.endpoints.thirdPartyCookiesIframe()),e.setAttribute("sandbox","allow-storage-access-by-user-activation allow-scripts allow-same-origin"),e.setAttribute("title","keycloak-3p-check-iframe"),e.style.display="none",document.body.appendChild(e);let t=new Promise(r=>{let i=n=>{e.contentWindow===n.source&&(n.data!=="supported"&&n.data!=="unsupported"||(n.data==="unsupported"&&(a(this,te,"f").call(this,`[TIDECLOAK] Your browser is blocking access to 3rd-party cookies, this means:

 - It is not possible to retrieve tokens without redirecting to the TideCloak server (a.k.a. no support for silent authentication).
 - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).

For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers`),a(this,b,"f").enable=!1,this.silentCheckSsoFallback&&(this.silentCheckSsoRedirectUri=void 0)),document.body.removeChild(e),window.removeEventListener("message",i),r()))};window.addEventListener("message",i,!1)});return await Yt(t,this.messageReceiveTimeout,"Timeout when waiting for 3rd party check iframe message.")},Tt=async function(e){var t,r,i;let n=a(this,p,"m",G).call(this,window.location.href);if(n?.newUrl&&window.history.replaceState(window.history.state,"",n.newUrl),n&&n.valid){await a(this,p,"m",Ae).call(this),await a(this,p,"m",j).call(this,n);return}let s=async l=>{let d={};l||(d.prompt="none"),e.locale&&(d.locale=e.locale),await this.login(d)},c=async()=>{switch(e.onLoad){case"check-sso":a(this,b,"f").enable?(await a(this,p,"m",Ae).call(this),await a(this,p,"m",he).call(this)||(this.silentCheckSsoRedirectUri?await a(this,p,"m",Ve).call(this):await s(!1))):this.silentCheckSsoRedirectUri?await a(this,p,"m",Ve).call(this):await s(!1);break;case"login-required":await s(!0);break;default:throw new Error("Invalid value for onLoad")}};if(e.token&&e.refreshToken)if(a(this,p,"m",ge).call(this,e.token,e.refreshToken,e.idToken),a(this,b,"f").enable)await a(this,p,"m",Ae).call(this),await a(this,p,"m",he).call(this)&&((t=this.onAuthSuccess)===null||t===void 0||t.call(this),a(this,p,"m",Be).call(this));else try{await this.updateToken(-1),(r=this.onAuthSuccess)===null||r===void 0||r.call(this)}catch(l){if((i=this.onAuthError)===null||i===void 0||i.call(this),e.onLoad)await c();else throw l}else e.onLoad&&await c()},Ae=async function(){if(!a(this,b,"f").enable||a(this,b,"f").iframe)return;let e=document.createElement("iframe");a(this,b,"f").iframe=e,e.setAttribute("src",this.endpoints.checkSessionIframe()),e.setAttribute("sandbox","allow-storage-access-by-user-activation allow-scripts allow-same-origin"),e.setAttribute("title","keycloak-session-iframe"),e.style.display="none",document.body.appendChild(e);let t=i=>{var n;if(i.origin!==a(this,b,"f").iframeOrigin||((n=a(this,b,"f").iframe)===null||n===void 0?void 0:n.contentWindow)!==i.source||!(i.data==="unchanged"||i.data==="changed"||i.data==="error"))return;i.data!=="unchanged"&&this.clearToken();let s=a(this,b,"f").callbackList;a(this,b,"f").callbackList=[];for(let c of s.reverse())i.data==="error"?c(new Error("Error while checking login iframe")):c(null,i.data==="unchanged")};window.addEventListener("message",t,!1),await new Promise(i=>{e.addEventListener("load",()=>{let n=this.endpoints.authorize();n.startsWith("/")?a(this,b,"f").iframeOrigin=globalThis.location.origin:a(this,b,"f").iframeOrigin=new URL(n).origin,i()})})},he=async function(){if(!a(this,b,"f").iframe||!a(this,b,"f").iframeOrigin)return;let e=`${this.clientId} ${this.sessionId?this.sessionId:""}`,t=a(this,b,"f").iframeOrigin;return await new Promise((i,n)=>{var s,c;let l=(d,h)=>d?n(d):i(h);a(this,b,"f").callbackList.push(l),a(this,b,"f").callbackList.length===1&&((c=(s=a(this,b,"f").iframe)===null||s===void 0?void 0:s.contentWindow)===null||c===void 0||c.postMessage(e,t))})},Ve=async function(){let e=document.createElement("iframe"),t=await this.createLoginUrl({prompt:"none",redirectUri:this.silentCheckSsoRedirectUri});return e.setAttribute("src",t),e.setAttribute("sandbox","allow-storage-access-by-user-activation allow-scripts allow-same-origin"),e.setAttribute("title","keycloak-silent-check-sso"),e.style.display="none",document.body.appendChild(e),await new Promise((r,i)=>{let n=async s=>{if(s.origin!==window.location.origin||e.contentWindow!==s.source)return;let c=a(this,p,"m",G).call(this,s.data);try{await a(this,p,"m",j).call(this,c),r()}catch(l){i(l)}document.body.removeChild(e),window.removeEventListener("message",n)};window.addEventListener("message",n)})},G=function(e){let t=a(this,p,"m",gt).call(this,e);if(!t)return;let r=a(this,pe,"f").get(t.state);return r&&(t.valid=!0,t.redirectUri=r.redirectUri,t.storedNonce=r.nonce,t.prompt=r.prompt,t.pkceCodeVerifier=r.pkceCodeVerifier,t.loginOptions=r.loginOptions),t},gt=function(e){let t=[];switch(this.flow){case"standard":t=["code","state","session_state","kc_action_status","kc_action","iss","doken"];break;case"implicit":t=["access_token","token_type","id_token","state","session_state","expires_in","kc_action_status","kc_action","iss","doken"];break;case"hybrid":t=["access_token","token_type","id_token","code","state","session_state","expires_in","kc_action_status","kc_action","iss","doken"];break}t.push("error"),t.push("error_description"),t.push("error_uri");let r=new URL(e),i="",n;if(this.responseMode==="query"&&r.searchParams.size>0?(n=a(this,p,"m",Fe).call(this,r.search,t),r.search=n.paramsString,i=r.toString()):this.responseMode==="fragment"&&r.hash.length>0&&(n=a(this,p,"m",Fe).call(this,r.hash.substring(1),t),r.hash=n.paramsString,i=r.toString()),n?.oauthParams){if(this.flow==="standard"||this.flow==="hybrid"){if((n.oauthParams.code||n.oauthParams.error)&&n.oauthParams.state)return n.oauthParams.newUrl=i,n.oauthParams}else if(this.flow==="implicit"&&(n.oauthParams.access_token||n.oauthParams.error)&&n.oauthParams.state)return n.oauthParams.newUrl=i,n.oauthParams}},Fe=function(e,t){let r=new URLSearchParams(e),i={};for(let[n,s]of Array.from(r.entries()))t.includes(n)&&(i[n]=s,r.delete(n));return{paramsString:r.toString(),oauthParams:i}},j=async function(e){var t,r,i,n;let{code:s,error:c,prompt:l,doken:d}=e,h=new Date().getTime(),u=(f,g,m,k)=>{if(h=(h+new Date().getTime())/2,a(this,p,"m",ge).call(this,f,g,m,h,k),a(this,fe,"f")&&this.idTokenParsed&&this.idTokenParsed.nonce!==e.storedNonce)throw a(this,z,"f").call(this,"[TIDECLOAK] Invalid nonce, clearing token"),this.clearToken(),new Error("Invalid nonce.")};if(e.kc_action_status&&this.onActionUpdate&&this.onActionUpdate(e.kc_action_status,e.kc_action),c){if(l!=="none")if(e.error_description&&e.error_description==="authentication_expired")await this.login(e.loginOptions);else{let f={error:c,error_description:e.error_description};throw(t=this.onAuthError)===null||t===void 0||t.call(this,f),f}return}else this.flow!=="standard"&&(e.access_token||e.id_token)&&(u(e.access_token,void 0,e.id_token,d),(r=this.onAuthSuccess)===null||r===void 0||r.call(this));if(this.flow!=="implicit"&&s)try{let f=await a(this,p,"m",mt).call(this,this.endpoints.token(),s,this.clientId,e.redirectUri,e.pkceCodeVerifier);u(f.access_token,f.refresh_token,f.id_token,f.doken),this.flow==="standard"&&((i=this.onAuthSuccess)===null||i===void 0||i.call(this)),a(this,p,"m",Be).call(this)}catch(f){throw(n=this.onAuthError)===null||n===void 0||n.call(this),f}},Be=async function o(){a(this,b,"f").enable&&this.token&&(await ar(a(this,b,"f").interval*1e3),await a(this,p,"m",he).call(this)&&await a(this,p,"m",o).call(this))},mt=async function(e,t,r,i,n){let s=new URLSearchParams([["code",t],["grant_type","authorization_code"],["client_id",r],["redirect_uri",i]]);n&&s.append("code_verifier",n);let c={};if(a(this,A,"f")){let l=await a(this,A,"f").getAuthServerNonce();c.DPoP=await a(this,A,"f").generateDPoPProof(e,"POST",void 0,l)}try{return await X(e,{method:"POST",credentials:"include",headers:c,body:s})}catch(l){if(a(this,A,"f")&&l instanceof oe){let d=l.response.headers.get("DPoP-Nonce");if(d)return await a(this,A,"f").updateAuthServerNonce(d),c.DPoP=await a(this,A,"f").generateDPoPProof(e,"POST",void 0,d),await X(e,{method:"POST",credentials:"include",headers:c,body:s})}throw l}},Et=async function(e,t,r){let i=new URLSearchParams([["grant_type","refresh_token"],["refresh_token",t],["client_id",r]]),n={};if(a(this,A,"f")){let s=await a(this,A,"f").getAuthServerNonce();n.DPoP=await a(this,A,"f").generateDPoPProof(e,"POST",void 0,s)}try{return await X(e,{method:"POST",credentials:"include",headers:n,body:i})}catch(s){if(a(this,A,"f")&&s instanceof oe){let c=s.response.headers.get("DPoP-Nonce");if(c)return await a(this,A,"f").updateAuthServerNonce(c),n.DPoP=await a(this,A,"f").generateDPoPProof(e,"POST",void 0,c),await X(e,{method:"POST",credentials:"include",headers:n,body:i})}throw s}},At=function(){this.requestEnclave&&this.requestEnclave.checkEnclaveOpen()},Pe=function(){if(!this.tokenParsed)throw new Error("User authentication required to access voucher service");let e=this.tokenParsed.sid,t=a(this,p,"m",L).call(this);if(!t)throw new Error("Unable to build voucher URL, realm URL not configured");return`${t}/tidevouchers/fromUserSession?sessionId=${encodeURIComponent(e)}`},ge=function(e,t,r,i,n){if(this.tokenTimeoutHandle&&(clearTimeout(this.tokenTimeoutHandle),this.tokenTimeoutHandle=void 0),t?(this.refreshToken=t,this.refreshTokenParsed=Ce(t)):(delete this.refreshToken,delete this.refreshTokenParsed),r?(this.idToken=r,this.idTokenParsed=Ce(r)):(delete this.idToken,delete this.idTokenParsed),e){if(this.token=e,this.tokenParsed=Ce(e),this.sessionId=this.tokenParsed.sid,this.authenticated=!0,this.subject=this.tokenParsed.sub,this.realmAccess=this.tokenParsed.realm_access,this.resourceAccess=this.tokenParsed.resource_access,i&&(this.timeSkew=Math.floor(i/1e3)-this.tokenParsed.iat),typeof this.timeSkew=="number"&&(a(this,z,"f").call(this,"[TIDECLOAK] Estimated time difference between browser and server is "+this.timeSkew+" seconds"),this.onTokenExpired)){let s=(this.tokenParsed.exp-new Date().getTime()/1e3+this.timeSkew)*1e3;a(this,z,"f").call(this,"[TIDECLOAK] Token expires in "+Math.round(s/1e3)+" s"),s<=0?this.onTokenExpired():this.tokenTimeoutHandle=window.setTimeout(this.onTokenExpired,s)}}else delete this.token,delete this.tokenParsed,delete this.subject,delete this.realmAccess,delete this.resourceAccess,this.authenticated=!1;n?(this.doken=n,this.dokenParsed=Ce(n),this.requestEnclave&&typeof this.requestEnclave.updateDoken=="function"&&this.requestEnclave.updateDoken(this.doken)):(delete this.doken,delete this.dokenParsed,this.requestEnclave&&typeof this.requestEnclave.updateDoken=="function"&&this.requestEnclave.updateDoken(void 0))},L=function(){if(!(typeof this.authServerUrl>"u"))return`${Ge(this.authServerUrl)}/realms/${encodeURIComponent(this.realm)}`},Je=function(e){return t=>{this.enableLogging&&e.call(console,t)}};var tt=Qe;function vt(){if(typeof crypto>"u"||typeof crypto.randomUUID>"u")throw new Error("Web Crypto API is not available.");return crypto.randomUUID()}function Gt(o){return JSON.stringify({id_token:{acr:o}})}function jt(o){return Kt(o,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")}async function Jt(o,e){if(o!=="S256")throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${o}'.`);let t=new Uint8Array(await rr(e));return Pt(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function Kt(o,e){let t=Xt(o),r=new Array(o);for(let i=0;i<o;i++)r[i]=e.charCodeAt(t[i]%e.length);return String.fromCharCode.apply(null,r)}function Xt(o){if(typeof crypto>"u"||typeof crypto.getRandomValues>"u")throw new Error("Web Crypto API is not available.");return crypto.getRandomValues(new Uint8Array(o))}function Yt(o,e,t){let r,i=new Promise(function(n,s){r=window.setTimeout(function(){s(new Error(t||"Promise is not settled within timeout of "+e+"ms"))},e)});return Promise.race([o,i]).finally(function(){clearTimeout(r)})}function Qt(){try{return new Ze}catch{return new et}}var ne="kc-callback-",Ze=class{constructor(){K.add(this),globalThis.localStorage.setItem("kc-test","test"),globalThis.localStorage.removeItem("kc-test")}get(e){if(!e)return null;a(this,K,"m",Ke).call(this);let t=ne+e,r=globalThis.localStorage.getItem(t);return r?(globalThis.localStorage.removeItem(t),JSON.parse(r)):null}add(e){a(this,K,"m",Ke).call(this);let t=ne+e.state,r=JSON.stringify({...e,expires:Date.now()+3600*1e3});try{globalThis.localStorage.setItem(t,r)}catch{a(this,K,"m",Ct).call(this),globalThis.localStorage.setItem(t,r)}}};K=new WeakSet,Ke=function(){let e=Date.now();for(let[t,r]of a(this,K,"m",We).call(this)){let i=a(this,K,"m",wt).call(this,r);(i===null||i<e)&&globalThis.localStorage.removeItem(t)}},Ct=function(){for(let[e]of a(this,K,"m",We).call(this))globalThis.localStorage.removeItem(e)},We=function(){return Object.entries(globalThis.localStorage).filter(([e])=>e.startsWith(ne))},wt=function(e){let t;try{t=JSON.parse(e)}catch{return null}return ue(t)&&"expires"in t&&typeof t.expires=="number"?t.expires:null};var et=class{constructor(){ee.add(this)}get(e){if(!e)return null;let t=a(this,ee,"m",It).call(this,ne+e);return a(this,ee,"m",Xe).call(this,ne+e,"",a(this,ee,"m",Ye).call(this,-100)),t?JSON.parse(t):null}add(e){a(this,ee,"m",Xe).call(this,ne+e.state,JSON.stringify(e),a(this,ee,"m",Ye).call(this,60))}};ee=new WeakSet,It=function(e){let t=e+"=",r=document.cookie.split(";");for(let i=0;i<r.length;i++){let n=r[i];for(;n.charAt(0)===" ";)n=n.substring(1);if(n.indexOf(t)===0)return n.substring(t.length,n.length)}return""},Xe=function(e,t,r){let i=e+"="+t+"; expires="+r.toUTCString()+"; ";document.cookie=i},Ye=function(e){let t=new Date;return t.setTime(t.getTime()+e*60*1e3),t};function Pt(o){let e=String.fromCodePoint(...o);return btoa(e)}function Zt(o){let e=atob(o),t=e.length,r=new Uint8Array(t);for(let i=0;i<t;i++)r[i]=e.codePointAt(i);return r}function er(o){return new TextEncoder().encode(o)}function tr(o){return new TextDecoder("utf-8").decode(o)}async function rr(o){let t=new TextEncoder().encode(o);if(typeof crypto>"u"||typeof crypto.subtle>"u")throw new Error("Web Crypto API is not available.");return await crypto.subtle.digest("SHA-256",t)}function Ce(o){let[,e]=o.split(".");if(typeof e!="string")throw new Error("Unable to decode token, payload not found.");let t;try{t=ir(e)}catch(r){throw new Error("Unable to decode token, payload is not a valid Base64URL value.",{cause:r})}try{return JSON.parse(t)}catch(r){throw new Error("Unable to decode token, payload is not a valid JSON value.",{cause:r})}}function ir(o){let e=o.replaceAll("-","+").replaceAll("_","/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("Input is not of the correct length.")}try{return nr(e)}catch{return atob(e)}}function nr(o){return decodeURIComponent(atob(o).replace(/(.)/g,(e,t)=>{let r=t.charCodeAt(0).toString(16).toUpperCase();return r.length<2&&(r="0"+r),"%"+r}))}function ue(o){return typeof o=="object"&&o!==null}async function or(o){return await X(o)}async function yt(o){return await X(o)}async function X(o,e={}){let t=new Headers(e.headers);return t.set("Accept",Wt),await(await sr(o,{...e,headers:t})).json()}async function sr(o,e){let t=await fetch(o,e);if(!t.ok)throw new oe("Server responded with an invalid status.",{response:t});return t}function kt(o){if(!o)throw new Error("Unable to build authorization header, token is not set, make sure the user is authenticated.");return["Authorization",`bearer ${o}`]}function Ge(o){return o.endsWith("/")?o.slice(0,-1):o}var oe=class extends Error{constructor(e,t){super(e,t),this.response=t.response}},ar=o=>new Promise(e=>setTimeout(e,o));var rt=class{constructor(){this._tc=null,this._config=null,this._listeners={},this._hybridAuthenticated=!1,this._hybridReturnUrl=null,this._hybridCallbackHandled=!1,this._hybridCallbackPromise=null,this._cachedCallbackData=null,this._nativeAdapter=null,this._nativeAuthenticated=!1,this._nativeTokens=null,this._nativeCallbackUnsubscribe=null,this._nativeCallbackHandled=!1,this._nativeCallbackPromise=null,this._nativeCallbackProcessing=!1,this._nativeDoken=null,this._nativeDokenParsed=null,this._nativeVoucher=null,this._nativeRequestEnclave=null,this._nativeEncryptionCallbackUnsubscribe=null,this._pendingEncryptionRequests=new Map,this._dpopProvider=null}on(e,t){return this._listeners[e]||(this._listeners[e]=[]),this._listeners[e].push(t),this}off(e,t){return this._listeners[e]&&(this._listeners[e]=this._listeners[e].filter(r=>r!==t)),this}_emit(e,...t){(this._listeners[e]||[]).forEach(r=>{try{r(e,...t)}catch(i){console.error(`Error in "${e}" handler:`,i)}})}isHybridMode(){var e;return(((e=this._config)===null||e===void 0?void 0:e.authMode)||"frontchannel").toLowerCase()==="hybrid"}isNativeMode(){var e;return(((e=this._config)===null||e===void 0?void 0:e.authMode)||"frontchannel").toLowerCase()==="native"}async loadConfig(e){if(this._config)return this._config;if(!e||Object.keys(e).length===0)return console.warn("[loadConfig] empty config"),null;if(this._config=e,this.isHybridMode())return this._config;if(this.isNativeMode())return e.adapter?(this._nativeAdapter=e.adapter,this._config):(console.error("[loadConfig] Native mode requires config.adapter with platform-specific functions"),null);try{this._tc=new tt({url:e["auth-server-url"],realm:e.realm,clientId:e.resource,vendorId:e.vendorId,homeOrkUrl:e.homeOrkUrl,clientOriginAuth:e["client-origin-auth-"+window.location.origin]})}catch(t){return console.error("[loadConfig] Failed to initialize TideCloak client:",t),null}return this._tc.onReady=t=>this._emit("ready",t),this._tc.onAuthSuccess=()=>this._emit("authSuccess"),this._tc.onAuthError=t=>this._emit("authError",t),this._tc.onAuthRefreshSuccess=()=>this._emit("authRefreshSuccess"),this._tc.onAuthRefreshError=t=>this._emit("authRefreshError",t),this._tc.onAuthLogout=()=>this._emit("logout"),this._tc.onTokenExpired=()=>this._emit("tokenExpired"),this._config}async initIAM(e,t){var r,i;if(console.debug("[IAMService] Initializing IAM..."),typeof t=="function"&&this.on("ready",t),typeof window>"u")return this._emit("initError",new Error("SSR context: cannot initIAM on server")),!1;if(!await this.loadConfig(e))return this._emit("initError",new Error("Failed to load config")),!1;if(this.isHybridMode())return this._hybridCallbackHandled?(console.debug("[IAMService] Hybrid callback already handled"),this._hybridCallbackPromise?(console.debug("[IAMService] Waiting for pending token exchange..."),this._hybridCallbackPromise):(this._emit("ready",this._hybridAuthenticated),this._hybridAuthenticated)):(new URLSearchParams(window.location.search).get("code")&&(this._hybridCallbackHandled=!0),this._hybridCallbackPromise=(async()=>{let{handled:l,authenticated:d,returnUrl:h}=await this._handleHybridRedirectCallback({onMissingVerifierRedirectTo:"/login"});return this._hybridReturnUrl=h||null,l||this._emit("ready",this._hybridAuthenticated),this._hybridCallbackPromise=null,d||this._hybridAuthenticated})(),this._hybridCallbackPromise);if(this.isNativeMode())return this._nativeCallbackHandled?(console.debug("[IAMService] Native callback already handled"),this._nativeCallbackPromise?(console.debug("[IAMService] Waiting for pending native token exchange..."),this._nativeCallbackPromise):(this._emit("ready",this._nativeAuthenticated),this._nativeAuthenticated)):(this._nativeCallbackHandled=!0,this._nativeCallbackPromise=(async()=>{var c,l;if(!((c=this._config)===null||c===void 0)&&c.useDPoP&&!this._dpopProvider)try{let{authServerUrl:u,realm:f,clientId:g}=this._getNativeOIDCConfig(),m=`${u}/realms/${encodeURIComponent(f)}`,{DPoPSignatureProvider:k,BrowserSignatureAlgs:w}=await Promise.resolve().then(()=>(Oe(),qe)),I=this._config.useDPoP.alg||"ES256";this._dpopProvider=new k({issuerUrl:new URL(m),clientId:g,serverSupportedAlgorithms:[I],requestedAlgorithm:w[I]||w.ES256}),await this._dpopProvider.init(),console.debug("[IAMService] DPoP initialized for native mode")}catch(u){if(console.warn("[IAMService] Failed to initialize DPoP:",u),this._config.useDPoP.mode==="strict")throw u}let d=await this._nativeAdapter.getTokens(),h=((l=this._config)===null||l===void 0?void 0:l.sessionMode)||"online";if(d)if(console.debug("[IAMService] Found stored tokens in native mode, sessionMode:",h),d.doken&&(this._nativeDoken=d.doken,this._nativeDokenParsed=this._parseToken(d.doken),console.debug("[IAMService] Loaded doken from stored tokens")),d.voucher&&(this._nativeVoucher=d.voucher,console.debug("[IAMService] Loaded voucher from stored tokens")),h==="offline")this._nativeTokens=d,this._nativeAuthenticated=!0;else try{let f=JSON.parse(atob(d.accessToken.split(".")[1])).exp*1e3,g=Date.now();if(f>g)console.debug("[IAMService] Online mode: token valid, authenticating"),this._nativeTokens=d,this._nativeAuthenticated=!0;else if(d.refreshToken){console.debug("[IAMService] Online mode: token expired, attempting refresh");try{let m=await this._refreshNativeToken(d.refreshToken);this._nativeTokens=m,this._nativeAuthenticated=!0,await this._nativeAdapter.saveTokens(m),console.debug("[IAMService] Online mode: token refreshed successfully")}catch(m){console.debug("[IAMService] Online mode: refresh failed, user must login",m),await this._nativeAdapter.deleteTokens(),this._nativeAuthenticated=!1}}else console.debug("[IAMService] Online mode: token expired, no refresh token"),await this._nativeAdapter.deleteTokens(),this._nativeAuthenticated=!1}catch(u){console.error("[IAMService] Online mode: failed to parse token",u),await this._nativeAdapter.deleteTokens(),this._nativeAuthenticated=!1}return this._nativeCallbackUnsubscribe=this._nativeAdapter.onAuthCallback(async({code:u,voucher:f,error:g,errorDescription:m})=>{if(this._nativeCallbackProcessing||this._nativeAuthenticated){console.debug("[IAMService] Ignoring duplicate native callback");return}if(g){console.error("[IAMService] Native auth error:",g,m),this._emit("authError",new Error(`${g}: ${m||"Unknown error"}`));return}u&&await this._handleNativeCallback(u,f)}),this._nativeAdapter.onEncryptionCallback&&(this._nativeEncryptionCallbackUnsubscribe=this._nativeAdapter.onEncryptionCallback(({operation:u,requestId:f,result:g,error:m})=>{let k=this._pendingEncryptionRequests.get(f);k?(this._pendingEncryptionRequests.delete(f),m?k.reject(new Error(m)):g?k.resolve(g):k.reject(new Error("Empty result from encryption callback"))):console.warn("[IAMService] Received encryption callback for unknown requestId:",f)})),this._emit("ready",this._nativeAuthenticated),this._nativeCallbackPromise=null,this._nativeAuthenticated})(),this._nativeCallbackPromise);if(!this._tc){let c=new Error("TideCloak client not available");return this._emit("initError",c),!1}if(this._tc.didInitialize)return console.debug("[IAMService] IAM Already initialized once."),!!this._tc.tokenParsed;let s=!1;try{s=await this._tc.init({onLoad:"check-sso",silentCheckSsoRedirectUri:`${window.location.origin}/silent-check-sso.html`,pkceMethod:"S256",...((r=this._config)===null||r===void 0?void 0:r.useDPoP)&&{useDPoP:this._config.useDPoP},...((i=this._config)===null||i===void 0?void 0:i.checkLoginIframe)===!1&&{checkLoginIframe:!1}}),s&&this._tc.token&&(document.cookie=`kcToken=${this._tc.token}; path=/;`)}catch(c){console.error("[IAMService] TideCloak init error:",c),this._emit("initError",c)}return this._emit("ready",s),s}getTideCloakClient(){if(!this._tc)throw new Error("TideCloak client not initialized - call initIAM() first");return this._tc}getConfig(){if(!this._config)throw new Error("Config not loaded - call initIAM() first");return this._config}isLoggedIn(){return this.isHybridMode()?this._hybridAuthenticated:this.isNativeMode()?this._nativeAuthenticated:!!this.getTideCloakClient().token}async getToken(){if(this.isHybridMode())throw new Error("getToken() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){let t=await this._nativeAdapter.getTokens();if(!t)return null;let r=Date.now(),i=30*1e3;if(r>=t.expiresAt-i){console.debug("[IAMService] Native token expired, refreshing...");try{let n=await this._refreshNativeToken(t.refreshToken);return await this._nativeAdapter.saveTokens(n),this._nativeTokens=n,n.accessToken}catch(n){return console.error("[IAMService] Native token refresh failed:",n),null}}return t.accessToken}return this.getTokenExp()<3&&await this.updateIAMToken(),this.getTideCloakClient().token}getTokenExp(){var e;if(this.isHybridMode())throw new Error("getTokenExp() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){if(!(!((e=this._nativeTokens)===null||e===void 0)&&e.accessToken))return 0;try{let r=JSON.parse(atob(this._nativeTokens.accessToken.split(".")[1]));return Math.round(r.exp-Date.now()/1e3)}catch(r){return console.error("[IAMService] Failed to parse token for expiry:",r),0}}let t=this.getTideCloakClient();return Math.round(t.tokenParsed.exp+t.timeSkew-Date.now()/1e3)}getIDToken(){var e;if(this.isHybridMode())throw new Error("getIDToken() not available in hybrid mode - tokens are server-side");return this.isNativeMode()?((e=this._nativeTokens)===null||e===void 0?void 0:e.idToken)||null:this.getTideCloakClient().idToken}getName(){if(this.isHybridMode())throw new Error("getName() not available in hybrid mode - tokens are server-side");return this.isNativeMode()?this.getValueFromToken("preferred_username"):this.getTideCloakClient().tokenParsed.preferred_username}getReturnUrl(){return this._hybridReturnUrl}hasRealmRole(e){var t,r;if(this.isHybridMode())throw new Error("hasRealmRole() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){if(!(!((t=this._nativeTokens)===null||t===void 0)&&t.accessToken))return!1;try{return(((r=JSON.parse(atob(this._nativeTokens.accessToken.split(".")[1])).realm_access)===null||r===void 0?void 0:r.roles)||[]).includes(e)}catch(i){return console.error("[IAMService] Failed to parse token for realm role check:",i),!1}}return this.getTideCloakClient().hasRealmRole(e)}hasClientRole(e,t){var r,i,n,s;if(this.isHybridMode())throw new Error("hasClientRole() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){if(!(!((r=this._nativeTokens)===null||r===void 0)&&r.accessToken))return!1;try{let c=JSON.parse(atob(this._nativeTokens.accessToken.split(".")[1])),l=t||((i=this._config)===null||i===void 0?void 0:i.resource);return(((s=(n=c.resource_access)===null||n===void 0?void 0:n[l])===null||s===void 0?void 0:s.roles)||[]).includes(e)}catch(c){return console.error("[IAMService] Failed to parse token for client role check:",c),!1}}return this.getTideCloakClient().hasResourceRole(e,t)}getValueFromToken(e){var t,r;if(this.isHybridMode())throw new Error("getValueFromToken() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){if(!(!((t=this._nativeTokens)===null||t===void 0)&&t.accessToken))return null;try{let i=JSON.parse(atob(this._nativeTokens.accessToken.split(".")[1]));return i[e]!==void 0?i[e]:null}catch(i){return console.error("[IAMService] Failed to parse access token:",i),null}}return(r=this.getTideCloakClient().tokenParsed[e])!==null&&r!==void 0?r:null}getValueFromIDToken(e){var t,r;if(this.isHybridMode())throw new Error("getValueFromIDToken() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){if(!(!((t=this._nativeTokens)===null||t===void 0)&&t.idToken))return null;try{let i=JSON.parse(atob(this._nativeTokens.idToken.split(".")[1]));return i[e]!==void 0?i[e]:null}catch(i){return console.error("[IAMService] Failed to parse ID token:",i),null}}return(r=this.getTideCloakClient().idTokenParsed[e])!==null&&r!==void 0?r:null}async updateIAMToken(){if(this.isHybridMode())throw new Error("updateIAMToken() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){let i=this.getTokenExp();return i<30&&await this.getToken(),i<30}let e=this.getTideCloakClient(),t=await e.updateToken(),r=this.getTokenExp();return console.debug(t?`[updateIAMToken] Refreshed: ${r}s`:`[updateIAMToken] Still valid: ${r}s`),document.cookie=`kcToken=${e.token}; path=/;`,t}async forceUpdateToken(){var e;if(this.isHybridMode())throw new Error("forceUpdateToken() not available in hybrid mode - tokens are server-side");if(this.isNativeMode()){if(!((e=this._nativeTokens)===null||e===void 0)&&e.refreshToken)try{let n=await this._refreshNativeToken(this._nativeTokens.refreshToken);return this._nativeTokens=n,await this._nativeAdapter.saveTokens(n),!0}catch(n){return console.error("[IAMService] Native force refresh failed:",n),!1}return!1}document.cookie="kcToken=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT";let t=this.getTideCloakClient(),r=await t.updateToken(-1),i=this.getTokenExp();return console.debug(r?`[updateToken] Immediately refreshed: ${i}s`:`[updateToken] No refresh needed: ${i}s`),document.cookie=`kcToken=${t.token}; path=/;`,r}doLogin(e=""){var t,r;if(console.debug("[IAMService.doLogin] Called with returnUrl:",e),console.debug("[IAMService.doLogin] isHybridMode:",this.isHybridMode()),console.debug("[IAMService.doLogin] isNativeMode:",this.isNativeMode()),console.debug("[IAMService.doLogin] authMode config:",(t=this._config)===null||t===void 0?void 0:t.authMode),this.isHybridMode())return this._startHybridLogin(e).catch(i=>{throw console.error("[IAMService.doLogin] Error in hybrid login:",i),i});if(this.isNativeMode())return this._startNativeLogin(e).catch(i=>{throw console.error("[IAMService.doLogin] Error in native login:",i),i});this.getTideCloakClient().login({redirectUri:(r=this._config.redirectUri)!==null&&r!==void 0?r:`${window.location.origin}/auth/redirect`})}async doEncrypt(e){if(this.isHybridMode())throw new Error("Encrypt not supported in hybrid mode (tokens are server-side)");return this.isNativeMode()?this._nativeEncrypt(e):this.getTideCloakClient().encrypt(e)}async doDecrypt(e){if(this.isHybridMode())throw new Error("Decrypt not supported in hybrid mode (tokens are server-side)");return this.isNativeMode()?this._nativeDecrypt(e):this.getTideCloakClient().decrypt(e)}async secureFetch(e,t){if(this.isHybridMode())throw new Error("secureFetch() not available in hybrid mode - tokens are server-side");return this.isNativeMode()?this._nativeSecureFetch(e,t):this.getTideCloakClient().secureFetch(e,t)}async _nativeSecureFetch(e,t={}){if(!this._dpopProvider)return fetch(e,t);let r=await this.getToken();if(!r)return fetch(e,t);let i=typeof e=="string"?e:e.toString(),n=(t.method||"GET").toUpperCase(),s=new URL(i).origin,c=new Headers(t.headers||{}),l=c.get("Authorization")||"",d=l.startsWith("Bearer ")?l.substring(7):null;if(!d||d!==r)return fetch(e,t);let h=this._dpopProvider.getResourceServerNonce(s),u=await this._dpopProvider.generateDPoPProof(i,n,r,h);c.set("Authorization",`DPoP ${r}`),c.set("DPoP",u);let f=await fetch(e,{...t,headers:c}),g=f.headers.get("DPoP-Nonce");if(g&&this._dpopProvider.updateResourceServerNonce(s,g),f.status===401&&g){let m=await this._dpopProvider.generateDPoPProof(i,n,r,g);c.set("DPoP",m),f=await fetch(e,{...t,headers:c});let k=f.headers.get("DPoP-Nonce");k&&this._dpopProvider.updateResourceServerNonce(s,k)}return f}async doLogout(){var e;if(this.isHybridMode()){this._hybridAuthenticated=!1,this._hybridReturnUrl=null,this._emit("logout");return}if(this.isNativeMode()){if(await this._nativeAdapter.deleteTokens(),this._nativeTokens=null,this._nativeAuthenticated=!1,this._nativeDoken=null,this._nativeDokenParsed=null,this._nativeVoucher=null,this._nativeCallbackHandled=!1,this._nativeCallbackProcessing=!1,this._nativeCallbackPromise=null,this._nativeCallbackUnsubscribe&&(this._nativeCallbackUnsubscribe(),this._nativeCallbackUnsubscribe=null),this._nativeEncryptionCallbackUnsubscribe&&(this._nativeEncryptionCallbackUnsubscribe(),this._nativeEncryptionCallbackUnsubscribe=null),this._nativeRequestEnclave){try{this._nativeRequestEnclave.close()}catch(t){console.debug("[IAMService] Error closing request enclave:",t)}this._nativeRequestEnclave=null}this._emit("logout");return}document.cookie="kcToken=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT",this.getTideCloakClient().logout({redirectUri:(e=this._config.redirectUri)!==null&&e!==void 0?e:`${window.location.origin}/auth/redirect`})}getBaseUrl(){var e,t;return this.isHybridMode()?"":((t=(e=this._config)===null||e===void 0?void 0:e["auth-server-url"])===null||t===void 0?void 0:t.replace(/\/$/,""))||""}async _startHybridLogin(e=""){var t,r;if(typeof window>"u")throw new Error("Cannot login in SSR context");let i=(t=this._config)===null||t===void 0?void 0:t.oidc,n=(r=this._config)===null||r===void 0?void 0:r.tokenExchange;if(console.debug("[IAMService._startHybridLogin] Config:",{authorizationEndpoint:i?.authorizationEndpoint,clientId:i?.clientId,redirectUri:i?.redirectUri,tokenExchangeEndpoint:n?.endpoint}),!i?.authorizationEndpoint||!i?.clientId||!i?.redirectUri)throw new Error("Hybrid mode requires config.oidc.authorizationEndpoint, clientId, and redirectUri");if(!n?.endpoint)throw new Error("Hybrid mode requires config.tokenExchange.endpoint");console.debug("[IAMService] Generating PKCE...");let{verifier:s,challenge:c,method:l}=await we();console.debug("[IAMService] PKCE generated, verifier length:",s.length),sessionStorage.setItem("kc_pkce_verifier",s),sessionStorage.setItem("kc_return_url",e||"");let d=sessionStorage.getItem("kc_pkce_verifier");console.debug("[IAMService] Stored verifier in sessionStorage, retrieved length:",d?.length);let h=e?`__url_${e}`:"",u=i.scope||"openid profile email",f=`${i.authorizationEndpoint}?client_id=${encodeURIComponent(i.clientId)}&redirect_uri=${encodeURIComponent(i.redirectUri)}&response_type=code&scope=${encodeURIComponent(u)}&state=${encodeURIComponent(h)}&code_challenge=${encodeURIComponent(c)}&code_challenge_method=${encodeURIComponent(l)}`+(i.prompt?`&prompt=${encodeURIComponent(i.prompt)}`:"");console.debug("[IAMService] Redirecting to:",f.substring(0,100)+"..."),window.location.assign(f)}getHybridCallbackData(e={}){var t,r,i,n;let{clearStorage:s=!0,redirectUri:c,provider:l}=e;if(typeof window>"u")return{isCallback:!1,code:"",verifier:"",redirectUri:"",returnUrl:"",provider:"",error:null,errorDescription:null};if(this._cachedCallbackData)return console.debug("[IAMService.getHybridCallbackData] Returning cached data"),{...this._cachedCallbackData,redirectUri:c||this._cachedCallbackData.redirectUri,provider:l||this._cachedCallbackData.provider};let d=new URLSearchParams(window.location.search),h=d.get("error"),u=d.get("error_description"),f=d.get("code")||"",g=d.get("state")||"",k=(g.startsWith("__url_")?g.substring(6):"")||sessionStorage.getItem("kc_return_url")||"",w=sessionStorage.getItem("kc_pkce_verifier")||"",I=c||((r=(t=this._config)===null||t===void 0?void 0:t.oidc)===null||r===void 0?void 0:r.redirectUri)||"",se=l||((n=(i=this._config)===null||i===void 0?void 0:i.tokenExchange)===null||n===void 0?void 0:n.provider)||"tidecloak-auth",N=!!(f||h);console.debug("[IAMService.getHybridCallbackData] code:",f?f.substring(0,20)+"...":"(empty)"),console.debug("[IAMService.getHybridCallbackData] verifier:",w?`(length: ${w.length})`:"(empty)"),console.debug("[IAMService.getHybridCallbackData] redirectUri:",I),console.debug("[IAMService.getHybridCallbackData] returnUrl:",k),console.debug("[IAMService.getHybridCallbackData] clearStorage:",s,"isCallback:",N);let M={isCallback:N,code:f,verifier:w,redirectUri:I,returnUrl:k,provider:se,error:h,errorDescription:u};return N&&w&&(this._cachedCallbackData=M,console.debug("[IAMService.getHybridCallbackData] Cached callback data")),s&&N&&(sessionStorage.removeItem("kc_pkce_verifier"),sessionStorage.removeItem("kc_return_url"),console.debug("[IAMService.getHybridCallbackData] Cleared sessionStorage")),M}async _handleHybridRedirectCallback(e={}){var t,r,i,n,s;if(typeof window>"u")return{handled:!1,authenticated:!1,returnUrl:""};let c=new URLSearchParams(window.location.search),l=c.get("error"),d=c.get("error_description")||"An error occurred",h=c.get("code")||"",u=c.get("state")||"",g=(u.startsWith("__url_")?u.substring(6):"")||sessionStorage.getItem("kc_return_url")||"";if(l)return this._emit("authError",new Error(`${l}: ${d}`)),this._emit("ready",!1),{handled:!0,authenticated:!1,returnUrl:g};if(!h)return console.debug("[IAMService] No code in URL, not a callback page"),{handled:!1,authenticated:!1,returnUrl:""};console.debug("[IAMService] Code found in URL, checking for PKCE verifier...");let m=sessionStorage.getItem("kc_pkce_verifier")||"",k=((r=(t=this._config)===null||t===void 0?void 0:t.oidc)===null||r===void 0?void 0:r.redirectUri)||"";if(console.debug("[IAMService] Retrieved verifier from sessionStorage, length:",m.length),console.debug("[IAMService] Current origin:",window.location.origin),h&&m){let M=((n=(i=this._config)===null||i===void 0?void 0:i.tokenExchange)===null||n===void 0?void 0:n.provider)||"tidecloak-auth";this._cachedCallbackData={isCallback:!0,code:h,verifier:m,redirectUri:k,returnUrl:g,provider:M,error:null,errorDescription:null},console.debug("[IAMService] Cached callback data from _handleHybridRedirectCallback")}if(h.length>0&&m.length===0)return console.error("[IAMService] PKCE verifier missing! Code present but no verifier in sessionStorage."),console.debug("[IAMService] All sessionStorage keys:",Object.keys(sessionStorage)),e.onMissingVerifierRedirectTo&&window.location.assign(e.onMissingVerifierRedirectTo),this._emit("authError",new Error("Missing PKCE verifier (likely page refresh after it was consumed)")),this._emit("ready",!1),{handled:!0,authenticated:!1,returnUrl:g};sessionStorage.removeItem("kc_pkce_verifier"),sessionStorage.removeItem("kc_return_url");let w=(s=this._config)===null||s===void 0?void 0:s.tokenExchange,I=w?.endpoint,se=w?.provider||"tidecloak-auth",N=typeof w?.headers=="function"?w.headers():w?.headers||{};console.debug("[IAMService] Token exchange endpoint:",I),console.debug("[IAMService] Custom headers:",N);try{await Ue(I,{method:"POST",headers:N,body:JSON.stringify({accessToken:JSON.stringify({code:h,code_verifier:m,redirect_uri:k}),provider:se})}),this._hybridAuthenticated=!0,this._hybridReturnUrl=g||null,this._emit("authSuccess");let M=new URL(window.location.href);return["code","state","session_state","iss","error","error_description"].forEach(me=>M.searchParams.delete(me)),window.history.replaceState({},document.title,M.toString()),this._emit("ready",!0),{handled:!0,authenticated:!0,returnUrl:g}}catch(M){return this._hybridAuthenticated=!1,this._emit("authError",M),this._emit("ready",!1),{handled:!0,authenticated:!1,returnUrl:g}}}_getNativeOIDCConfig(){let e=this._config;return{authServerUrl:e["auth-server-url"],realm:e.realm,clientId:e.resource,scope:e.scope||"openid profile email"}}_getNativeEncryptionConfig(){let e=this._config;if(!e.vendorId)return null;let r=`client-origin-auth-${typeof window<"u"?window.location.origin:""}`,i=e[r];return{vendorId:e.vendorId,homeOrkUrl:e.homeOrkUrl,clientOriginAuth:i}}async _startNativeLogin(e=""){console.debug("[IAMService._startNativeLogin] Starting native login flow"),this._nativeAuthenticated=!1,this._nativeCallbackProcessing=!1;let t=this._nativeAdapter;if(!t)throw new Error("Native adapter not configured");let{authServerUrl:r,realm:i,clientId:n,scope:s}=this._getNativeOIDCConfig(),{verifier:c,challenge:l,method:d}=await we();console.debug("[IAMService._startNativeLogin] PKCE generated, verifier length:",c.length),sessionStorage.setItem("kc_pkce_verifier",c),e&&sessionStorage.setItem("kc_return_url",e);let h=await Promise.resolve(t.getRedirectUri());sessionStorage.setItem("kc_redirect_uri",h);let u=`${r}/realms/${encodeURIComponent(i)}/protocol/openid-connect/auth?client_id=${encodeURIComponent(n)}&redirect_uri=${encodeURIComponent(h)}&response_type=code&scope=${encodeURIComponent(s)}&code_challenge=${encodeURIComponent(l)}&code_challenge_method=${encodeURIComponent(d)}&prompt=login`;console.debug("[IAMService._startNativeLogin] Opening auth URL in external browser"),await t.openExternalUrl(u)}async _handleNativeCallback(e,t){if(this._nativeCallbackProcessing){console.debug("[IAMService._handleNativeCallback] Already processing callback, ignoring duplicate");return}this._nativeCallbackProcessing=!0,this._nativeCallbackHandled=!0,console.debug("[IAMService._handleNativeCallback] Handling native callback with code");let r=this._nativeAdapter,{authServerUrl:i,realm:n,clientId:s}=this._getNativeOIDCConfig(),c=sessionStorage.getItem("kc_pkce_verifier"),l=sessionStorage.getItem("kc_redirect_uri")||await Promise.resolve(r.getRedirectUri()),d=sessionStorage.getItem("kc_return_url")||"";if(sessionStorage.removeItem("kc_pkce_verifier"),sessionStorage.removeItem("kc_redirect_uri"),sessionStorage.removeItem("kc_return_url"),!c){console.debug("[IAMService._handleNativeCallback] PKCE verifier not found, callback already processed"),this._nativeCallbackProcessing=!1;return}try{let h=`${i}/realms/${encodeURIComponent(n)}/protocol/openid-connect/token`,u=new URLSearchParams({grant_type:"authorization_code",client_id:s,code:e,redirect_uri:l,code_verifier:c}),f={"Content-Type":"application/x-www-form-urlencoded"};if(this._dpopProvider){let w=await this._dpopProvider.getAuthServerNonce();f.DPoP=await this._dpopProvider.generateDPoPProof(h,"POST",void 0,w)}let g=await fetch(h,{method:"POST",headers:f,body:u.toString()});if(!g.ok&&this._dpopProvider){let w=g.headers.get("DPoP-Nonce");w&&(await this._dpopProvider.updateAuthServerNonce(w),f.DPoP=await this._dpopProvider.generateDPoPProof(h,"POST",void 0,w),g=await fetch(h,{method:"POST",headers:f,body:u.toString()}))}if(!g.ok){let w=await g.text();throw new Error(`Token exchange failed: ${w}`)}let m=await g.json();console.debug("[IAMService._handleNativeCallback] Token exchange successful");let k={accessToken:m.access_token,refreshToken:m.refresh_token,idToken:m.id_token,doken:m.doken,expiresAt:Date.now()+m.expires_in*1e3};await r.saveTokens(k),this._nativeTokens=k,this._nativeDoken=m.doken,this._nativeDokenParsed=m.doken?this._parseToken(m.doken):null,this._nativeAuthenticated=!0,this._nativeCallbackProcessing=!1,this._emit("authSuccess"),console.debug("[IAMService._handleNativeCallback] Native auth complete, returnUrl:",d)}catch(h){console.error("[IAMService._handleNativeCallback] Token exchange error:",h),this._nativeAuthenticated=!1,this._nativeCallbackProcessing=!1,this._emit("authError",h)}}async _refreshNativeToken(e){let{authServerUrl:t,realm:r,clientId:i}=this._getNativeOIDCConfig(),n=`${t}/realms/${encodeURIComponent(r)}/protocol/openid-connect/token`,s=new URLSearchParams({grant_type:"refresh_token",client_id:i,refresh_token:e}),c=await fetch(n,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:s.toString()});if(!c.ok){let d=await c.text();throw new Error(`Token refresh failed: ${d}`)}let l=await c.json();return l.doken&&(this._nativeDoken=l.doken,this._nativeDokenParsed=this._parseToken(l.doken),console.debug("[IAMService] Updated doken from token refresh")),{accessToken:l.access_token,refreshToken:l.refresh_token,idToken:l.id_token,doken:l.doken,expiresAt:Date.now()+l.expires_in*1e3}}_initNativeRequestEnclave(e){if(!this._nativeDoken)throw new Error("[IAMService] No doken available for encryption - user must be authenticated with Tide");if(!this._nativeDokenParsed)throw new Error("[IAMService] Doken not parsed");let t=this._getNativeEncryptionConfig();if(!t||!t.vendorId||!t.clientOriginAuth)throw new Error("[IAMService] Native encryption requires vendorId and client-origin-auth-{origin} in config");if(this._nativeRequestEnclave){console.debug("[IAMService] Reusing existing RequestEnclave");return}let r=this._nativeDokenParsed["t.uho"]||t.homeOrkUrl;if(!r)throw new Error("[IAMService] Home ORK URL not available - check doken or config.homeOrkUrl");console.debug("[IAMService] Initializing native RequestEnclave",{homeOrkOrigin:r,vendorId:t.vendorId,voucherURL:e}),this._nativeRequestEnclave=new q({homeOrkOrigin:r,signed_client_origin:t.clientOriginAuth,vendorId:t.vendorId,voucherURL:e,isRunningLocal:!1}).init({doken:this._nativeDoken,dokenRefreshCallback:async()=>{if(await this.forceUpdateToken(),!this._nativeDoken)throw new Error("[IAMService] No doken available after token refresh");return this._nativeDoken},requireReloginCallback:async()=>{console.warn("[IAMService] Re-authentication required for encryption"),this._emit("authError",new Error("Re-authentication required"))}})}_buildEncryptionPageUrl(e,t,r,i,n){let{authServerUrl:s,realm:c,clientId:l}=this._getNativeOIDCConfig(),d=this._getNativeEncryptionConfig(),h=`${s}/realms/${encodeURIComponent(c)}/tide-encrypt`,u=new URL(h);return u.searchParams.set("operation",e),u.searchParams.set("requestId",t),u.searchParams.set("data",r),u.searchParams.set("tags",i),u.searchParams.set("callback",n),u.searchParams.set("vendorId",d?.vendorId||""),u.searchParams.set("clientId",l),u.toString()}async _doExternalBrowserOperation(e,t,r){let i=this._nativeAdapter,n=`${e}_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,s;if(i.getEncryptionRedirectUri)s=await Promise.resolve(i.getEncryptionRedirectUri());else{let h=await Promise.resolve(i.getRedirectUri());h.endsWith("/callback")?s=h.replace("/callback","/encrypt/callback"):s=h+"/encrypt/callback"}let c=JSON.stringify(r),l=this._buildEncryptionPageUrl(e,n,t,c,s);console.debug(`[IAMService] Opening external browser for ${e}:`,{requestId:n,callbackUrl:s,urlLength:l.length});let d=new Promise((h,u)=>{this._pendingEncryptionRequests.set(n,{resolve:h,reject:u});let f=setTimeout(()=>{this._pendingEncryptionRequests.has(n)&&(this._pendingEncryptionRequests.delete(n),u(new Error(`Encryption ${e} timed out after 60 seconds`)))},6e4),g=this._pendingEncryptionRequests.get(n),m=g.resolve,k=g.reject;g.resolve=w=>{clearTimeout(f),m(w)},g.reject=w=>{clearTimeout(f),k(w)}});return await i.openExternalUrl(l),d}_getNativeVoucherUrl(){var e;if(!(!((e=this._nativeTokens)===null||e===void 0)&&e.accessToken))throw new Error("[IAMService] No access token available for voucher URL");let t=this._parseToken(this._nativeTokens.accessToken);if(!t)throw new Error("[IAMService] Failed to parse access token for voucher URL");let r=t.sid;if(!r)throw new Error("[IAMService] No session ID in access token for voucher URL");let{authServerUrl:i,realm:n}=this._getNativeOIDCConfig();return`${i}/realms/${encodeURIComponent(n)}/tidevouchers/fromUserSession?sessionId=${encodeURIComponent(r)}`}_nativeHasRealmRole(e){var t,r;if(!(!((t=this._nativeTokens)===null||t===void 0)&&t.accessToken))return!1;try{let i=this._parseToken(this._nativeTokens.accessToken);return(((r=i?.realm_access)===null||r===void 0?void 0:r.roles)||[]).includes(e)}catch{return!1}}async _nativeEncrypt(e){if(await this.updateIAMToken(),!Array.isArray(e))throw new Error("Pass array as parameter");if(!this._nativeAuthenticated)throw new Error("Not authenticated");let t=e.map(n=>{if(typeof n!="object"||n===null)throw new Error("All entries must be an object to encrypt");for(let s of["data","tags"])if(!n[s])throw new Error(`The object is missing the required '${s}' property.`);if(!Array.isArray(n.tags))throw new Error("tags must be provided as a string array");if(typeof n.data!="string"&&!(n.data instanceof Uint8Array))throw new Error("data must be provided as string or Uint8Array");for(let s of n.tags){if(typeof s!="string")throw new Error("tags must be provided as an array of strings");if(!this._nativeHasRealmRole(`_tide_${s}.selfencrypt`))throw new Error(`User has not been given any access to '${s}'`)}return{data:typeof n.data=="string"?this._stringToUint8Array(n.data):n.data,tags:n.tags,isRaw:typeof n.data!="string"}}),r=this._getNativeVoucherUrl();return console.debug("[IAMService._nativeEncrypt] Using voucherURL:",r),this._initNativeRequestEnclave(r),(await this._nativeRequestEnclave.encrypt(t)).map((n,s)=>t[s].isRaw?n:this._bytesToBase64(n))}async _nativeDecrypt(e){if(await this.updateIAMToken(),!Array.isArray(e))throw new Error("Pass array as parameter");if(!this._nativeAuthenticated)throw new Error("Not authenticated");let t=e.map(n=>{if(typeof n!="object"||n===null)throw new Error("All entries must be an object to decrypt");for(let s of["encrypted","tags"])if(!n[s])throw new Error(`The object is missing the required '${s}' property.`);if(!Array.isArray(n.tags))throw new Error("tags must be provided as a string array");if(typeof n.encrypted!="string"&&!(n.encrypted instanceof Uint8Array))throw new Error("encrypted must be provided as string or Uint8Array");for(let s of n.tags){if(typeof s!="string")throw new Error("tags must be provided as an array of strings");if(!this._nativeHasRealmRole(`_tide_${s}.selfdecrypt`))throw new Error(`User has not been given any access to '${s}'`)}return{encrypted:typeof n.encrypted=="string"?this._base64ToBytes(n.encrypted):n.encrypted,tags:n.tags,isRaw:typeof n.encrypted!="string"}}),r=this._getNativeVoucherUrl();return console.debug("[IAMService._nativeDecrypt] Using voucherURL:",r),this._initNativeRequestEnclave(r),(await this._nativeRequestEnclave.decrypt(t)).map((n,s)=>t[s].isRaw?n:this._stringFromUint8Array(n))}_stringToUint8Array(e){return new TextEncoder().encode(e)}_stringFromUint8Array(e){return new TextDecoder("utf-8").decode(e)}_bytesToBase64(e){let t=String.fromCodePoint(...e);return btoa(t)}_base64ToBytes(e){let t=atob(e),r=t.length,i=new Uint8Array(r);for(let n=0;n<r;n++)i[n]=t.codePointAt(n);return i}_parseToken(e){if(!e)return null;try{return JSON.parse(atob(e.split(".")[1]))}catch(t){return console.error("[IAMService] Failed to parse token:",t),null}}destroy(){this._nativeCallbackUnsubscribe&&(this._nativeCallbackUnsubscribe(),this._nativeCallbackUnsubscribe=null),this._nativeEncryptionCallbackUnsubscribe&&(this._nativeEncryptionCallbackUnsubscribe(),this._nativeEncryptionCallbackUnsubscribe=null);for(let[e,t]of this._pendingEncryptionRequests)t.reject(new Error("IAMService destroyed"));if(this._pendingEncryptionRequests.clear(),this._nativeRequestEnclave){try{this._nativeRequestEnclave.close()}catch(e){console.debug("[IAMService] Error closing request enclave:",e)}this._nativeRequestEnclave=null}}},cr=new rt;var x=cr;var Se=class{constructor(e){this.realm=e}setRealm(e){this.realm=e}getRealm(){if(this.realm)return this.realm;let e=x.getConfig();return e?.realm||"master"}async fetch(e,t={}){let r=await x.getToken(),i=x.getBaseUrl(),n=e.startsWith("http")?e:`${i}${e}`,s=await fetch(n,{...t,headers:{"Content-Type":"application/json",Authorization:`Bearer ${r}`,...t.headers}});if(!s.ok){let l=await s.text().catch(()=>"");throw new Error(`API error ${s.status}: ${l||s.statusText}`)}let c=await s.text();return c?JSON.parse(c):null}async fetchWithFormData(e,t){let r=await x.getToken(),i=x.getBaseUrl(),n=e.startsWith("http")?e:`${i}${e}`,s=await fetch(n,{method:"POST",headers:{Authorization:`Bearer ${r}`},body:t});if(!s.ok){let l=await s.text().catch(()=>"");throw new Error(`API error ${s.status}: ${l||s.statusText}`)}let c=await s.text();return c?JSON.parse(c):null}async getRoles(){let e=this.getRealm();return this.fetch(`/admin/realms/${e}/roles`)}async getRole(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/roles/${encodeURIComponent(e)}`)}async createRole(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/roles`,{method:"POST",body:JSON.stringify(e)})}async updateRole(e,t){let r=this.getRealm();return this.fetch(`/admin/realms/${r}/roles/${encodeURIComponent(e)}`,{method:"PUT",body:JSON.stringify(t)})}async deleteRole(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/roles/${encodeURIComponent(e)}`,{method:"DELETE"})}async getClientUUID(e){if(!e){let i=x.getConfig();e=i?.resource||i?.clientId}if(!e)throw new Error("No client ID available");let t=this.getRealm(),r=await this.fetch(`/admin/realms/${t}/clients?clientId=${encodeURIComponent(e)}`);if(!r||r.length===0)throw new Error(`Client not found: ${e}`);return r[0].id}async getClientRoles(e){let t=this.getRealm(),r=await this.getClientUUID(e);return this.fetch(`/admin/realms/${t}/clients/${r}/roles`)}async getClientRole(e,t){let r=this.getRealm(),i=await this.getClientUUID(t);return this.fetch(`/admin/realms/${r}/clients/${i}/roles/${encodeURIComponent(e)}`)}async createClientRole(e,t){let r=this.getRealm(),i=await this.getClientUUID(t);return this.fetch(`/admin/realms/${r}/clients/${i}/roles`,{method:"POST",body:JSON.stringify(e)})}async updateClientRole(e,t,r){let i=this.getRealm(),n=await this.getClientUUID(r);return this.fetch(`/admin/realms/${i}/clients/${n}/roles/${encodeURIComponent(e)}`,{method:"PUT",body:JSON.stringify(t)})}async deleteClientRole(e,t){let r=this.getRealm(),i=await this.getClientUUID(t);return this.fetch(`/admin/realms/${r}/clients/${i}/roles/${encodeURIComponent(e)}`,{method:"DELETE"})}async getUsers(e={}){let t=this.getRealm(),r=new URLSearchParams;e.first!==void 0&&r.set("first",String(e.first)),e.max!==void 0&&r.set("max",String(e.max)),e.search&&r.set("search",e.search);let i=r.toString();return this.fetch(`/admin/realms/${t}/users${i?`?${i}`:""}`)}async getUser(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/users/${e}`)}async createUser(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/users`,{method:"POST",body:JSON.stringify(e)})}async updateUser(e,t){let r=this.getRealm();return this.fetch(`/admin/realms/${r}/users/${e}`,{method:"PUT",body:JSON.stringify(t)})}async deleteUser(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/users/${e}`,{method:"DELETE"})}async setUserEnabled(e,t){let r=this.getRealm();return this.fetch(`/admin/realms/${r}/users/${e}`,{method:"PUT",body:JSON.stringify({enabled:t})})}async getTideLinkUrl(e,t,r=43200){let i=await x.getToken(),n=x.getBaseUrl(),s=this.getRealm(),c=x.getConfig(),l=c?.resource||c?.clientId,d=new URLSearchParams({userId:e,lifespan:String(r),redirect_uri:t,client_id:l}),h=`${n}/admin/realms/${s}/tideAdminResources/get-required-action-link?${d.toString()}`,u=await fetch(h,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${i}`},body:JSON.stringify(["link-tide-account-action"])});if(!u.ok){let f=await u.text().catch(()=>"");throw new Error(`API error ${u.status}: ${f||u.statusText}`)}return u.text()}async getUserRoles(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/users/${e}/role-mappings/realm`)}async addUserRoles(e,t){let r=this.getRealm();return this.fetch(`/admin/realms/${r}/users/${e}/role-mappings/realm`,{method:"POST",body:JSON.stringify(t)})}async removeUserRoles(e,t){let r=this.getRealm();return this.fetch(`/admin/realms/${r}/users/${e}/role-mappings/realm`,{method:"DELETE",body:JSON.stringify(t)})}async getTemplates(){let e=this.getRealm();try{return await this.fetch(`/admin/realms/${e}/tide-admin/policy-templates`)}catch{return[]}}async getUserChangeRequests(){let e=this.getRealm();try{return(await this.fetch(`/admin/realms/${e}/tide-admin/change-set/users/requests`)||[]).map(r=>({...r,changeSetId:r.draftRecordId,changeSetType:r.changeSetType,actionType:r.actionType}))}catch{return[]}}async getRoleChangeRequests(){let e=this.getRealm();try{return(await this.fetch(`/admin/realms/${e}/tide-admin/change-set/roles/requests`)||[]).map(r=>({...r,changeSetId:r.draftRecordId,changeSetType:r.changeSetType,actionType:r.actionType}))}catch{return[]}}async getPendingChangeSets(){let[e,t]=await Promise.all([this.getUserChangeRequests(),this.getRoleChangeRequests()]);return[...e,...t]}async approveChangeSet(e){let t=this.getRealm(),r=new FormData;return r.append("changeSetId",e.changeSetId),r.append("actionType",e.actionType),r.append("changeSetType",e.changeSetType),this.fetchWithFormData(`/admin/realms/${t}/tideAdminResources/add-review`,r)}async rejectChangeSet(e){let t=this.getRealm(),r=new FormData;return r.append("changeSetId",e.changeSetId),r.append("actionType",e.actionType),r.append("changeSetType",e.changeSetType),this.fetchWithFormData(`/admin/realms/${t}/tideAdminResources/add-rejection`,r)}async commitChangeSet(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/tide-admin/change-set/commit`,{method:"POST",body:JSON.stringify({changeSetId:e.changeSetId,actionType:e.actionType,changeSetType:e.changeSetType})})}async cancelChangeSet(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/tide-admin/change-set/cancel`,{method:"POST",body:JSON.stringify({changeSetId:e.changeSetId,actionType:e.actionType,changeSetType:e.changeSetType})})}async getRawChangeSetRequest(e){let t=this.getRealm();return this.fetch(`/admin/realms/${t}/tide-admin/change-set/sign/batch`,{method:"POST",body:JSON.stringify({changeSets:[e]})})}async approveChangeSetWithSignature(e,t){let r=this.getRealm(),i=new FormData;return i.append("changeSetId",e.changeSetId),i.append("actionType",e.actionType),i.append("changeSetType",e.changeSetType),i.append("requests",t),this.fetchWithFormData(`/admin/realms/${r}/tideAdminResources/add-review`,i)}async getAccessLogs(e={}){let t=this.getRealm(),r=new URLSearchParams;e.first!==void 0&&r.set("first",String(e.first)),e.max!==void 0&&r.set("max",String(e.max));let i=r.toString();return this.fetch(`/admin/realms/${t}/events${i?`?${i}`:""}`)}},bi=new Se;window.IAMService=x;})();
